{"meta":{"title":"zsk's personal blog","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-09-23T04:38:02.126Z","updated":"2021-09-23T04:38:02.126Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-09-24T09:58:00.217Z","updated":"2021-09-24T09:58:00.217Z","comments":false,"path":"artitalk/index.html","permalink":"http://example.com/artitalk/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-23T14:01:53.223Z","updated":"2021-09-23T14:01:53.223Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"关于 您正在与&nbsp;zsk&nbsp;对话中... bot_ui_ini()"},{"title":"","date":"2021-09-23T04:36:58.729Z","updated":"2021-09-23T04:36:58.729Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-09-23T04:36:35.979Z","updated":"2021-09-23T04:36:35.979Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-09-23T04:35:53.515Z","updated":"2021-09-23T04:35:53.515Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"刷题日记 day-1","slug":"刷题日记 Day01","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T09:00:34.973Z","comments":true,"path":"2021/09/24/刷题日记 Day01/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20Day01/","excerpt":"","text":"34. 在排序数组中查找元素的第一个和最后一个位置题目描述给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 主要思路仔细一看这就是二分查找的应用典型呀，虽然我知道要用二分查找，但是在做的时候还是没有一个明确的思路，搞了一晚上还是没能攻破，诶，看了题解以后就感觉好简单。分析一下我下面写的代码，防止以后再看的时候就看不懂了。 这个Solution包括三个函数，第一个就是主函数，第二个和第三个如名字一样，分别是寻找target在数组的第一个位置和最后一次出现的位置，二分查找的最重要的代码体就是： int left=0; int right=nums.length-1; while(left&lt;=right) &#123; int mid=left+(right-left)/2; if(nums[mid]&gt;target) right=mid-1; if(nums[mid]&lt;target) left=mid+1; &#125; return left; 注释1这个地方为啥多此一举 (right=mid-1;) ？这个是为了找到第一个出现target位置的操作，注释2这个地方加一个判断就是要搞清楚在数组里找没找到target，这两个地方都是针对这个题目做出的改变。 整体来说，就是利用二分查找在数组里找了两次target，分别找到第一个和最后一个出现target的位置。 代码如下class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int firstPosition=searchFirstPosition(nums,target); if(nums.length==0||firstPosition==-1) return new int[]&#123;-1,-1&#125;; int lastPosition=searchLastPosition(nums,target); return new int[]&#123;firstPosition,lastPosition&#125;; &#125; public int searchFirstPosition(int[] nums,int target)&#123; int left=0; int right=nums.length-1; while(left&lt;=right) &#123; int mid=left+(right-left)/2; if(nums[mid]==target)//注释1 right=mid-1; else if(nums[mid]&lt;target) left=mid+1; else right=mid-1; &#125; if(left!=nums.length&amp;&amp;nums[left]==target)//注释2 return left; else return -1; &#125; public int searchLastPosition(int[] nums,int target)&#123; int left=0; int right=nums.length-1; while(left&lt;=right) &#123; int mid=left+(right-left)/2; if(nums[mid]==target) left=mid+1; else if(nums[mid]&lt;target) left=mid+1; else right=mid-1; &#125; return right; &#125; &#125; 小结二分查找很有精神！！！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-10","slug":"刷题日记 day 10","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:28:49.570Z","comments":true,"path":"2021/09/24/刷题日记 day 10/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%2010/","excerpt":"","text":"写在前面​ 李奶奶的动态规划！！！真的觉得自己智商过低，不适合刷动态规划。于是我找了一个稍微简单一点的链表问题，题目来自于：**LeetCode 143. 重排链表**，这个题目的解法思路很多，我也想出来几种。但由于我对链表结构的不够熟悉，不能完美的利用链表结构特点，只能理解别人写的题解。题解的思路也很好理解： 找到链表的中点分割链表 将分割后的后半部分进行链表反转 将翻转后的链表和前半部分进行合并 题目的背景如下： 给定一个单链表 L 的头节点 head ，单链表 L 表示为： L0 → L1 → … → Ln-1 → Ln请将其重新排列后变为： L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → … 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 实例： 输入: head = [1,2,3,4]输出: [1,4,2,3] 输入: head = [1,2,3,4,5]输出: [1,5,2,4,3] 代码如下/** * Definition for singly-linked list. 这是关于链表结构的说明 * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */ class Solution &#123; public void reorderList(ListNode head) &#123; if(head.next==null||head.next.next==null) return ; ListNode fast=head; ListNode slow=head; //快慢指针 找到中点 //具体是快指针一次走两步 慢指针一次走一步 快指针走到头 慢指针走到链表中点 while(fast.next!=null&amp;&amp;fast.next.next!=null)&#123; fast=fast.next.next; slow=slow.next; &#125; ListNode newHead=slow.next; slow.next=null; newHead=reverse(newHead); while(newHead!=null)&#123; ListNode temp = newHead.next; newHead.next = head.next; head.next = newHead; head = newHead.next; newHead = temp; &#125; &#125; //反转链表 public ListNode reverse(ListNode head)&#123; ListNode pre=null; ListNode next=null; while(head!=null)&#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre; &#125; &#125; 写在后面​ 这个题目思路虽然不难想，但是实现有很多技巧，例如快慢指针、反转链表、合并链表这些小技巧，这都是阶梯模板。任重道远！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-4","slug":"刷题日记 day 4","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T11:07:28.694Z","comments":true,"path":"2021/09/24/刷题日记 day 4/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%204/","excerpt":"","text":"题目背景介绍今天写的是回溯算法解决的n皇后，在LeetCode上是第51题，难度是困难！ n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 首先来看一下皇后们的约束条件： 不能同行 不能同列 不能同斜线 唉，是个在二维数组上的回溯，这可咋整呢？ 代码实现class Solution &#123; List&lt;List&lt;String&gt;&gt; res=new ArrayList&lt;&gt;();//存放正确的结果集合 public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; char[][] chessboard=new char[n][n];//定义一个棋盘数组 //下面给棋盘数组赋值这个方式很轻巧，值得借鉴 for(char[] c:chessboard)&#123; Arrays.fill(c,&#39;.&#39;); &#125; backtracking(n,0,chessboard); return res; &#125; public void backtracking(int n,int row,char[][] chessboard)&#123; //函数参数row指的是棋盘的行数，也是递归树的深度 if(row==n)&#123; //当棋盘的行数等于n，就说明每一行都正确摆放了Q，可以加入正确的结果集合res res.add(new ArrayList&lt;&gt;(transform(chessboard))); return; &#125; for(int col=0;col&lt;n;++col)&#123; //这里的col指的是棋盘的列数，先判断当前棋盘的情况是不是满足要求 if(check(row,col,n,chessboard))&#123; chessboard[row][col]=&#39;Q&#39;;//处理棋盘 backtracking(n,row+1,chessboard); chessboard[row][col]=&#39;.&#39;;//回溯 撤销处理棋盘的操作 &#125; &#125; &#125; public List transform(char[][] chessboard)&#123; //这个函数是将字符二维数组转化为list List&lt;String&gt; path=new ArrayList&lt;&gt;(); for(char[] c:chessboard)&#123; path.add(String.copyValueOf(c)); &#125; return path; &#125; public boolean check(int row,int col,int n,char[][] chessboard)&#123; // 这个函数是检查棋盘的现状是否满足条件，主要从三个方面纵的方向不能有多个Q // 两个对角线上不能有多个Q for(int i=0;i&lt;n;i++)&#123; //检查列 if(chessboard[i][col]==&#39;Q&#39;) return false; &#125; for(int i=row-1,j=col-1;i&gt;=0&amp;&amp;j&gt;=0;i--,j--)&#123; //检查45度对角线 if(chessboard[i][j]==&#39;Q&#39;) return false; &#125; for(int i=row-1,j=col+1;i&gt;=0&amp;&amp;j&lt;=n-1;i--,j++)&#123; //检查135度对角线 if(chessboard[i][j]==&#39;Q&#39;) return false; &#125; return true; &#125; &#125; 分析与小结先来看看我画的递归树吧，这样讲的比较清晰。 可以看出来递归树的深度由棋盘的行数决定，每一层的情况由棋盘的列数决定。这也就是我们写题的着手方向。这个题比较需要注意的点在于这个图的建立，以及检查函数里对角线的排查，至于为啥不排查每一行的元素？这个你看图，每一行的Q都是独立的，所以不需要。这个不是我自己想出来的，是看别的大佬的题解。但弄懂以及把那个图画好也花了我不少时间。任重道远，仍需不断前行！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-5","slug":"刷题日记 day 5","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:14.981Z","comments":true,"path":"2021/09/24/刷题日记 day 5/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%205/","excerpt":"","text":"初探贪心算法​ 终于结束了回溯，老实说回溯是真的有点难，虽然有模板，但是很多问题的解决方式不尽相同。刷了也有20道题差不多，但是真正有印象的就几题。不过现在学到贪心了，我有点难受。它没有模板，就一个局部最优的算法思想。但是解决问题想到了这个思想，真的非常简单。想不到就呵呵了。 两个题目下面是我今天被贪心折磨的日常：LeetCode第53题 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums = [1]输出：1 示例 3： 输入：nums = [0]输出：0 示例 4： 输入：nums = [-1]输出：-1 示例 5： 输入：nums = [-100000]输出：-100000 提示： 1 &lt;= nums.length &lt;= 3 * 104-105 &lt;= nums[i] &lt;= 105 暴力解法 class Solution &#123; public int maxSubArray(int[] nums) &#123; int maxValue=Integer.MIN_VALUE; for(int i=0;i&lt;nums.length;i++)&#123; int count=0; for(int j=i;j&lt;nums.length;j++)&#123; count+=nums[j]; maxValue=count&gt;maxValue?count:maxValue; &#125; &#125; return maxValue; &#125; &#125; 时间复杂度是：O(n^2) 但是如果用贪心算法来写： class Solution &#123; public int maxSubArray(int[] nums) &#123; int maxValue=Integer.MIN_VALUE; int count=0; for(int i=0;i&lt;nums.length;i++)&#123; count+=nums[i]; if(count&gt;maxValue) maxValue=count; if(count&lt;0) count=0; &#125; return maxValue; &#125; &#125; 这个算法的时间复杂度很明显是O(n),初看还不是很明白，其实就是用了一个小技巧：我们都知道如果count后面加的是一个负数，就一定会让和变小，所以我们一旦碰到让count小于0的数据，就直接将count初始化为0，在从头开始记录count。这样看起来就使每一步都使得count是最大的，因为让count变成负数的元素我不会加入。这就是贪心的体现，但是这个很难想到呀！所以说贪心没有模板、只有一次次的踩坑积累经验，才可能想到有时候可以使用贪心。 LeetCode第55题 跳跃游戏给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。 示例 1： 输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。示例 2： 输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 提示： 1 &lt;= nums.length &lt;= 3 * 1040 &lt;= nums[i] &lt;= 105 这个题目就有点符合现实了，有点像跳台阶，其实可以从后往前跳，判断前一个节点是否能到达最后一个节点，如果可以就更新当前节点为最后一个节点。这是一种思路。但是贪心法更赖皮： class Solution &#123; public boolean canJump(int[] nums) &#123; int cover=0; if(nums.length==1) return true; for(int i=0;i&lt;=cover;i++)&#123; cover=Math.max(i+nums[i],cover); if(cover&gt;=nums.length-1) return true; &#125; return false; &#125; &#125; 看完也是不明所以，看了题解后感慨十分赖皮！其实就是看一个覆盖范围。你当前能走的步数的最大值是否覆盖到了最后一个元素，如果是肯定能走到。每次更新最大覆盖范围，这也是贪心法。 分析与小结做贪心的题目就感觉手上有本秘籍，很厉害。但是就是不会用，但是当你以为它就是废物时，丢掉了，别人捡起来，看了秘籍后成了你梦想成为的人。唉。任重而道远！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-6","slug":"刷题日记 day 6","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:19.641Z","comments":true,"path":"2021/09/24/刷题日记 day 6/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%206/","excerpt":"","text":"写在前面这两天被贪心折磨，贪心真的很难想到，初看题目有点看不懂，好不容易推演了两个测试，明白了题目的用意，但还是无从下手。一看题解代码和分析，就感觉自己是个傻zi。 今天写了两个贪心的题目，738. 单调递增的数字以及714. 买卖股票的最佳时机含手续费，这两题的代码都很简单，但都非常难想到。 代码如下 单调递增的数字 class Solution &#123; //解法一：暴力解法 很容易想到但是会超时 public int monotoneIncreasingDigits(int n) &#123; for(int i=n;i&gt;0;i--)&#123; if(check(i)) return i; &#125; return 0; &#125; public boolean check(int num)&#123; int max=10; while(num!=0)&#123; int t=num%10;//取出最后一位元素 if(t&lt;=max)&#123; max=t; &#125;else&#123; return false; &#125; num/=10; &#125; return true; &#125; &#125; class Solution &#123; /*解法二：从后往前遍历 n转化为字符数组a后 若a[i]&lt;a[i-1] 说明不是递增的 要进行调整 具体操作就是吧a[i-1]减一，以及把i以后的数字全部变成9，听起来很抽象。 如：n等于332 它的变化顺序是 332-&gt;329-&gt;299 这样经过两次调整就能得到正确结果，而且这 个算法时间复杂度是O(n). */ public int monotoneIncreasingDigits(int n) &#123; String s=String.valueOf(n);//转换成字符串更简单 int len=s.length(); int flag=len; char[] a=s.toCharArray(); for(int i=len-1;i&gt;=1;i--)&#123; if(a[i]&lt;a[i-1])&#123; flag=i; a[i-1]--; &#125; &#125; for(int i=flag;i&lt;len;i++)&#123; a[i]=&#39;9&#39;; &#125; return Integer.parseInt(new String(a)); &#125; &#125; 买卖股票的最佳时机含手续费 class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int minPay=prices[0]+fee; int sum=0; for(int i:prices)&#123; if(i+fee&lt;minPay) minPay=i+fee; else if(i&gt;minPay)&#123; sum+=i-minPay; minPay=i; &#125; &#125; return sum; &#125; &#125; 写在后面第二个题太难想到了，我也不想写啥分析，头晕。好在是终于结束了贪心(仓促)，明天动态规划！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-7","slug":"刷题日记 day 7","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:24.428Z","comments":true,"path":"2021/09/24/刷题日记 day 7/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%207/","excerpt":"","text":"何为动态规划​ 动态规划就是Dynamic Programming，简称DP。如果解决一个问题需要解决它的很多重叠子问题，这个时候就需要用到动态规划。 ​ 动态规划的解题步骤： 确定dp数组以及下标的含义 确定递推公式 dp数组的初始化 确定遍历顺序 举例推导dp数组 题目背景今天写的第一题是我们的老熟题：509. 斐波那契数 。这个题目之前用的是递归，今天是动态规划。今天的第二题就有点难理解了：746. 使用最小花费爬楼梯。 代码如下 斐波那契数 class Solution &#123; public int fib(int n) &#123; if(n&lt;=1) return n; int[] dp=new int[n+1]; dp[0]=0; dp[1]=1; for(int i=2;i&lt;dp.length;i++)&#123; dp[i]=dp[i-1]+dp[i-2];//这个就是递推公式 &#125; return dp[n]; &#125; &#125; 使用最小花费爬楼梯 class Solution &#123; public int minCostClimbingStairs(int[] cost) &#123; int len=cost.length; int[] dp=new int[len]; dp[0]=cost[0]; dp[1]=cost[1]; for(int i=2;i&lt;len;i++)&#123; //递推关系式 dp[i]=Math.min(dp[i-1]+cost[i],dp[i-2]+cost[i]); &#125; return Math.min(dp[len-1],dp[len-2]); &#125; &#125; 分析与小结​ 从题解代码就可以很清楚的看出，dp数组的下标就表示第几个斐波那契数，而数组相对存储的就是第几个斐波那契数的值，递推公式题目也给了。所以解题十分方便。而第二题是斐波那契数列的变形，非常巧妙。我们每到达一个阶梯，都是从它的上一级或者上两级阶梯，所以当前花费最小将从它的上一级花费和上上一级花费之中诞生。这就是递推关系式： dp[i]=Math.min(dp[i-1]+cost[i],dp[i-2]+cost[i]);的由来。 ​ 今天的动态规划就到这里，持之以恒！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-8","slug":"刷题日记 day 8","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:29.558Z","comments":true,"path":"2021/09/24/刷题日记 day 8/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%208/","excerpt":"","text":"初探01背包问题​ 记得我第一次遇到01背包还是上学期，在算法课上听过老师讲动态规划和回溯的时候，当时觉得这个问题理解起来这么简单，为啥这么重要？当我开始想着写出它的代码。呵呵，一个菜鸡怎么可能会写代码呢。今天终于刷到了01背包问题，发现这个问题的原型是很简单不错，但是它的变形就不是那么容易看穿了。 ​ 一切的动态规划最重要的就是找递推关系式，在这个问题中。我们的动规数组**dp[j]**，的含义是啥呢？它表示：容量为j的背包所能容纳的最大的物品价值。它的递推公式是： **dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]);**因为背包外的物品只有两个选择：放入背包或者不放入。所以背包的价值也就在这两个状态里产生，不放就是dp[j]，放进去了，就是之前背包的价值加上这个物品的价值。非常好理解！ ​ 然后我们就要思考一下dp数组的初始化问题，很明显dp[0]肯定是0，因为背包内没有物品，自然也就没有最大价值一说了。 ​ 再者就要考虑一下遍历顺序，我们必须倒序遍历数组。这是因为：为了保证物品i只会被放入一次！ 例如：物品0的重量为weight[0]=1,其价值value[0]=15， 那么将它放入背包容量为1的情况下：dp[1]=dp[1-weight[0]]+value[0]=15 将它放入背包容量为2的情况下：dp[2]=dp[2-weight[0]]+value[0]=30; 这时就会发现放入容量为2的背包的时候，最大价值应该是15，但是正序遍历的结果是30，这就是因为物品0被重复放入了。 反之我们先放入容量为2背包，在放入容量为1的背包就不会出现这样的问题。 ​ 下面有两个背包问题的实例，请仔细揣摩： 两个问题问题一：416. 分割等和子集 题目背景：给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 题目实例： 输入：nums = [1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。 输入：nums = [1,2,3,5] 输出：false 解释：数组不能分割成两个元素和相等的子集。 问题二：1049. 最后一块石头的重量 II 题目背景：有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎；如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。 题目实例： 输入：stones = [2,7,4,1,8,1]输出：1解释：组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。 解决代码问题一class Solution &#123; public boolean canPartition(int[] nums) &#123; int sum=0; //初始化dp数组的容量 int[] dp=new int[200*100+1]; for(int i=0;i&lt;nums.length;i++)&#123; sum+=nums[i]; &#125; //如果不能分成完全相等的两堆或者说两个子集 就return false if(sum%2==1) return false; //我们的目标是在背包里尝试装入最大价值为sum/2的物品 int target=sum/2; for(int i=0;i&lt;nums.length;i++)&#123; //注意这里是逆向遍历 for(int j=target;j&gt;=nums[i];j--)&#123; //递推公式 老套路了 dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i]); &#125; &#125; /*最后这个判断很灵性：如果背包容量为target时的最大价值也为target 就说明是可以分为最大子集为原数组集合的一半*/ if(dp[target]==target) return true; return false; &#125; &#125; 问题二class Solution &#123; public int lastStoneWeightII(int[] stones) &#123; int sum=0; int[] dp=new int[30*100/2+1]; for(int x:stones)&#123; sum+=x; &#125; int target=sum/2; for(int i=0;i&lt;stones.length;i++)&#123; for(int j=target;j&gt;=stones[i];j--)&#123; dp[j]=Math.max(dp[j],dp[j-stones[i]]+stones[i]); &#125; &#125; return (sum-dp[target])-dp[target]; &#125; &#125; 小结与分析​ 问题一的思路主要就是：将原数组划分成两个最大的子集，两个子集的和是相等的就return true。就可以理解为将原数组的元素放入一个背包，看看背包的最大值是否能达到原数组的一半。具体分析过程就在代码注释里面。 ​ 问题二？ 看看代码不就会了？(狗头) 哈哈哈","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-3","slug":"刷题日记 day 9","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:35.658Z","comments":true,"path":"2021/09/24/刷题日记 day 9/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%209/","excerpt":"","text":"初识完全背包​ 完全背包是背包问题的变形之一，老实说01背包我也才半知半解，今天看题解也还是雾中看花。完全背包就是背包只有一个，但是物品可以重复放入无数次。即每种物品有无数件。 ​ 首先我们列出01背包的核心代码： for(int i=0;i&lt;weight.length;i++)&#123;//遍历物品 for(int j=bagWeight;j&gt;=weight[i];j--)&#123;//遍历背包容量 dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]); &#125; &#125; 01背包内嵌的for循环是从大到小遍历，为了保证每个物品仅被添加一次。 而完全背包的物品可以添加多次，所以内层循环是要从小到大： for(int i=0;i&lt;weight.length;i++)&#123;//遍历物品 for(int j=weight[i];j&lt;bagWeight;j++)&#123;//遍历背包容量 dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]); &#125; &#125; 两个小题第一题：518. 零钱兑换 II给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。 假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数 实例： 输入：amount = 5, coins = [1, 2, 5]输出：4解释：有四种方式可以凑成总金额：5=55=2+2+15=2+1+1+15=1+1+1+1+1 第二题：377. 组合总和 Ⅳ给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。 题目数据保证答案符合 32 位整数范围。 实例： 输入：nums = [1,2,3], target = 4输出：7解释：所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合 代码详解第一题class Solution &#123; public int change(int amount, int[] coins) &#123; int[] dp=new int[amount+1]; dp[0]=1; for(int i=0;i&lt;coins.length;i++)&#123;//遍历物品 for(int j=coins[i];j&lt;=amount;j++)&#123;//遍历背包 dp[j]+=dp[j-coins[i]]; &#125; &#125; return dp[amount]; &#125; &#125; 第二题class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; int[] dp=new int[target+1]; dp[0]=1; for(int i=0;i&lt;=target;i++)&#123;//遍历背包 for(int j=0;j&lt;nums.length;j++)&#123;//遍历物品 if(i-nums[j]&gt;=0)&#123; dp[i]+=dp[i-nums[j]]; &#125; &#125; &#125; return dp[target]; &#125; &#125; 分析与小结这个完全背包，这里有两种类型：组合和排列。 从代码可以看出来：组合问题for循环是先遍历物品，再遍历背包，而排列问题for循环先遍历背包，再遍历物品。 全是套路呀！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-2","slug":"刷题日记day 2","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T10:25:23.584Z","comments":true,"path":"2021/09/24/刷题日记day 2/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0day%202/","excerpt":"","text":"写在前面好久没写博客了，虽然我的博客没人看，但是我觉得写博客是为了将自己的知识水平提高。写博客还可以让以后回顾知识变得更简单。之前一直没写主要是没啥兴趣，刷题在刚开始简直折磨，不夸张的说开始每一道题都是看答案的，有的看了答案也没弄懂，简直不知所云。对Java的集合类和数据结构也不是很熟悉，很多常用的方法函数不知道。经过20天左右的时间，我基本对刷题有一点的感觉了，开始越刷越快了。这个时候我想要慢下来，慢慢把刷的题总结一下。这就是再次写博客的理由。 题目概述及解法今天刷的还是回溯算法系列，这一题是：LeetCode第131题—分割回文串 题目的意思是：给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 回文串 是正着读和反着读都一样的字符串。 示例 1： 输入：s = “aab”输出：[[“a”,”a”,”b”],[“aa”,”b”]]示例 2： 输入：s = “a”输出：[[“a”]] 提示： 1 &lt;= s.length &lt;= 16s 仅由小写英文字母组成 解法代码：class Solution &#123; List&lt;List&lt;String&gt;&gt; res= new ArrayList&lt;&gt;();//存放正确结果的集合 Deque&lt;String&gt; path=new LinkedList&lt;&gt;();//存放单个正确结果(这里选择双端队列，若选择list删除时会出现错误) public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; backtracking(s,0); return res; &#125; public void backtracking(String s,int index)&#123;//回溯函数(也是递归函数) //确定回溯的终止条件(本题是： 当截取字符串的位置到达字符串最后一位就说明此次获取完成) if(index&gt;=s.length())&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; //for循环是解空间树的横向遍历，而回溯函数是解空间树的纵向遍历 for(int i=index;i&lt;s.length();i++)&#123; //先判断是否是回文串，是就截取放入path中，不是就跳过这次循环 if(isHuiWen(s,index,i))&#123; String str=s.substring(index,i+1); path.addLast(str); &#125;else&#123; continue; &#125; backtracking(s,i+1);//回溯函数(i+1是为了不再重复的截取) path.removeLast();//回溯 撤销之前处理节点的过程 &#125; &#125; //下面这个函数是判断是否是回文串 public boolean isHuiWen(String s,int index,int end)&#123; for(int i=index,j=end;i&lt;j;i++,j--)&#123; if(s.charAt(i)!=s.charAt(j)) return false; &#125; return true; &#125; &#125; 解法我在代码上做了详细的注释说明，主要就是截取字符串和数据结构Deque的选择。 写在后面虽然每天写的题不只一题，但是要是全部都记录下来，有点费时间，还是每天找一个喜欢的记录，这样也挺好的。 ​ 加油","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-3","slug":"刷题日记day 3","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:05.131Z","comments":true,"path":"2021/09/24/刷题日记day 3/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0day%203/","excerpt":"","text":"题目概述LeetCode第46题：全排列 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1： 输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]示例 2： 输入：nums = [0,1]输出：[[0,1],[1,0]]示例 3： 输入：nums = [1]输出：[[1]] 提示： 1 &lt;= nums.length &lt;= 6-10 &lt;= nums[i] &lt;= 10nums 中的所有整数 互不相同 解决代码class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();//存放正确结果的集合 List&lt;Integer&gt; path=new ArrayList&lt;&gt;();//存放单个正确的结果 public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; boolean[] used=new boolean[nums.length];//需要一个数组来判断集合的元素是否重复使用 backtracking(nums,used); return res; &#125; //子集问题和排列问题最大的不同，就是函数参数不再需要index，而是换成了boolean数组 public void backtracking(int[] nums,boolean[] used)&#123; //当path存放的元素到了全排列的数组的大小就可以停止，并传入res中 if(path.size()==nums.length)&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i=0;i&lt;nums.length;i++)&#123; //used数组就是记录path里面哪些元素已经被使用了，一个排列里元素只能使用一次 if(used[i]==true) continue; used[i]=true; path.add(nums[i]); backtracking(nums,used); path.remove(path.size()-1); used[i]=false; &#125; &#125; &#125; 分析小结这个题目是回溯算法的另一个擅长的拿手好戏，全排列和子集、组合问题的最大不同就是不需要传起始地址，因为每一层的元素可以重复使用，但是在一个分支里每个元素都只能用一次。下面是我画的一张解空间树的图，可以加深理解。 同时也想说，第一次使用画图工具，好难用，但是不用这个肯定画的又丑又难看懂。还是要继续努力，学习新知识！！！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"标签测试","slug":"标签测试","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:27:10.600Z","comments":true,"path":"2021/09/24/标签测试/","link":"","permalink":"http://example.com/2021/09/24/%E6%A0%87%E7%AD%BE%E6%B5%8B%E8%AF%95/","excerpt":"","text":"text带 下划线 的文本；带 着重号 的文本；带 波浪线 的文本；带 删除线 的文本 键盘样式的文本：⌘ + D 密码样式的文本：这里没有验证码 note这里可以是一段有用的希望能引人注意的信息 checkbox 纯文本测试 radio 纯文本测试 timeline2021-09-23 timeline测试 2021-09-22 1、 2021-09-21 2、 2021-09-23 3、 folding 这是一个折叠框 其他的还有好多元素实在太丰富了，我写个博客还用得着这么多？太看得起我了也hhh","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}],"author":"zsk"},{"title":"test","slug":"front-matter的测试","date":"2021-09-22T16:00:00.000Z","updated":"2021-09-23T05:41:26.588Z","comments":true,"path":"2021/09/23/front-matter的测试/","link":"","permalink":"http://example.com/2021/09/23/front-matter%E7%9A%84%E6%B5%8B%E8%AF%95/","excerpt":"","text":"this is a test!","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}],"author":"zsk"},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2021-09-22T10:51:47.372Z","updated":"2021-09-22T10:53:03.523Z","comments":true,"path":"2021/09/22/我的第一篇博客文章/","link":"","permalink":"http://example.com/2021/09/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"第一个标题第二个标题","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-09-22T10:34:25.959Z","updated":"2021-09-22T10:34:25.959Z","comments":true,"path":"2021/09/22/hello-world/","link":"","permalink":"http://example.com/2021/09/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]}
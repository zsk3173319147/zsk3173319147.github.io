{"meta":{"title":"zsk's personal blog","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-10-23T07:56:58.546Z","updated":"2021-09-23T14:01:53.223Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"关于 您正在与&nbsp;zsk&nbsp;对话中... bot_ui_ini()"},{"title":"所有分类","date":"2021-10-23T07:56:58.546Z","updated":"2021-09-23T04:35:53.515Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-10-23T07:56:58.538Z","updated":"2021-09-23T04:38:02.126Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-10-23T07:56:58.546Z","updated":"2021-09-24T09:58:00.217Z","comments":false,"path":"artitalk/index.html","permalink":"http://example.com/artitalk/index.html","excerpt":"","text":""},{"title":"","date":"2021-10-23T07:56:58.546Z","updated":"2021-09-23T04:36:58.729Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-10-23T07:56:58.546Z","updated":"2021-09-23T04:36:35.979Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构复习","slug":"数据结构复习","date":"2022-09-23T16:00:00.000Z","updated":"2023-02-25T05:13:25.539Z","comments":true,"path":"2022/09/24/数据结构复习/","link":"","permalink":"http://example.com/2022/09/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"数据结构第一章 逻辑结构分为线性结构和非线性结构 存储结构又被称为物理结构，主要有顺序存储、链式存储、索引存储、散列存储。 算法的五个重要特性：有穷性、确定性、可行性、输入、输出。 什么是时间复杂度：一个语句的执行次数被称为语句的频度，所有语句的频度之和记为**T(n)**，他是算法问题规模n的函数，时间复杂度主要就研究它的数量级。 $$T(n)=O(f(n))$$ 算法的时间复杂度不仅取决于问题的规模，而且取决于带输入数据的性质。 第二章 顺序表可以随机存取，而单链表只能顺序存取 头指针是指向链表第一个节点的指针,头结点是带头结点链表的第一个节点，节点内通常不存储信息。 引入头结点的两个好处：首先可以使链表第一个位置上的操作和其他位置一样，无需特殊处理，其次可以是使空表和非空表的处理统一起来 单链表的头插和尾插，头插法关键在于：s-&gt;next=L-&gt;next;L-&gt;next=s; 尾插法关键在于：LNode *r=L;r-&gt;next=s;r=s; 链表的删除操作：LNode *q=p-&gt;next;p-&gt;next=q-&gt;next;free(q); 如何快速找到一个单链表的三分之一处？ 答：可以使用双指针法，一个指针fast一次走三步，一个指针slow一次走一步，fast指针结束，返回slow指针的位置。 循环单链表的判空条件是它是否等于头指针，循环单链表不设头指针而仅设置尾指针，这样对表头和表尾的操作只需要O(1)的时间复杂度 静态链表：借助数组来描述线性表的链式存储结构，这里的指针是指节点的相对地址(数组下标)，在操作系统文件管理那里有个文件的显式链接的FAT文件分配表那里有应用。 第三章 循环队列： 初始时：Q.front=Q.rear=0; 进队：Q.rear=(Q.rear+1)%MaxSize 出队：Qfront=(Q.front+1)%MaxSize 队列长度：(Q.rear+MaxSize-Q.front)%MaxSize 队满条件:(Q.rear+1)%MaxSize==Q.front 队空条件：Q.front==Q.rear 为了区分队空和队满有三种处理方式： 牺牲一个存储单元来区分队空还是队满 增设表示数据元素个数的数据成员 增设tag数据成员，tag为0则队空，tag为1则队满 双端队列：允许两端都可以入队和出队的队列 第四章 树中的节点数等于所有节点的度数之和加一 完全二叉树：一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。 特点是：叶子节点只会出现在最后两层；节点编号i若小于等于n/2向下取整，则为分支节点，否则为叶子结点；若存在度为1的节点，那么这个节点有且只能有一个；且该节点只有左孩子无右孩子； 二叉树的性质： 非空二叉树的叶子结点数等于度为2的节点数加一 非空二叉树第k层上至多有2的k-1次方个节点 高度为h的二叉树至多有2的h次方减一个节点 二叉树的遍历，后序遍历的非递归算法中必须使用到栈，层次遍历需要用到队列。 线索二叉树：在n个节点的二叉树中有n+1个空指针，引入线索二叉树就是为了加快查找节点前驱和后继的速度 树：树的三种常用存储结构： 双亲表示法：就是静态链表类似的结构 孩子表示法：拉链法 孩子兄弟表示法：还是二叉树，只不过变成了左孩子右兄弟 树、二叉树和森林的转换 树转换成二叉树的规则是左孩子右兄弟。森林转换成二叉树的规则是先把森林中的每棵树转换成二叉树，再把它们的根视为兄弟关系连接起来。将二叉树转换成森林的规则是把根的右链断开。 树的先根遍历和后根遍历对应二叉树的先序遍历和中序遍历 WPL(带权路径长度)：从根出发到任意节点的路径长度与该点权值的乘积，称为该节点的带权路径长度。所有叶节点的带权路径长度之和称为树的WPL，在哈夫曼树中WPL等于所有非叶结点的权值之和 哈夫曼树: 在含有n个带权叶节点的二叉树中，WPL最小的称为哈夫曼树。(哈夫曼树中不存在度为1的节点) 哈夫曼编码：是可变字长编码的一种，利用哈夫曼树可以设计出总长度最短的二进制前缀编码。 哈夫曼编码的应用：数据压缩、文件压缩、图像编码处理 第五章 简单图：不存在重复边；不存在顶点到自身的边 完全图：对于无向图，边的取值范围是0到n(n-1)/2,对于有向图，边的取值范围是0到**n(n-1)** 连通分量:无向图的极大连通子图 强连通分量：有向图的极大强连通子图 生成树：包含图中所有顶点的极小连通子图 无向图的全部顶点的度之和等于边数的两倍；有向图的全部顶点的入度之和和出度之和相等且等于边数 若一个图有n个顶点，并且有大于n-1条边，则此图一定有环 图的邻接矩阵： 无向图的邻接矩阵一定是一个对称矩阵，并且唯一。实际存储只需要存储上(下)三角矩阵的元素 对于无向图，邻接矩阵第i行非零元素的个数刚好是该顶点的度 对于有向图，邻接矩阵第i行非零元素的个数刚好是该顶点的出度；邻接矩阵第j列非零元素的个数刚好是该顶点的入度 稠密图适合邻接矩阵，稀疏图适合邻接表 图的邻接表： 在有向图的邻接表表示法中，求给定顶点的出度只需计算邻接表中结点的个数，但求其顶点的入度需要遍历全部的邻接表。 邻接表中存在两种节点，顶点表节点和边表节点 **广度优先搜索(BFS)**：类似于二叉树的层序遍历,是一种分层查找过程，它不是一个递归算法，为了实现逐层访问，必须借助一个辅助队列，记忆正在访问节点的下一层节点。时间复杂度为O(|V|的平方),空间复杂度为O(|V|),使用BFS可以求非带权图(或者权值一样)的单源最短路径，这是由BFS总是按照距离从近到远遍历图中每个顶点决定的 **深度优先搜索(DFS)**：类似于二叉树的先序遍历，DFS是一个递归算法，需要借助递归工作栈，时间复杂度为O(|V|+|E|),空间复杂度为O(|V|) 图的遍历算法可以判断图的连通性 无向连通图最多几条边，最少几条? 答：最多n*(n-1)/2,最少n-1 最小生成树：给定一个带有权值的连通图（连通网），从众多的生成树中筛选出权值总和最小的生成树，即为该图的最小生成树 一般来说最小生成树不唯一，但当带权连通图中任意一个环所包含的边的权值均不相同时，其MST是唯一的。 最小生成树边的权值之和总是唯一的，其边数为顶点数减一。 Prim算法和Kruskal算法的区别： 最短路径：带权路径长度最短的那条路径称为最短路径。 广度优先算法求解最短路径针对无权图(或者权值一样)而言，求带权有向图一般两种算法：迪杰斯特拉算法和弗洛伊德算法。 迪杰斯特拉算法基于贪心策略，求源点到某个特定顶点的最短路径和到其他所有顶点的最短路径一样复杂，时间复杂度都为O(|V|2),当边上带有负权值时，迪杰斯特拉算法并不适用 弗洛伊德算法时间复杂度为O(|V|3)，允许图中带有负权值的边，但不允许带有负权值边的回路 拓扑排序：使用邻接表存储时拓扑排序的时间复杂度为O(|V|+|E|)，实用邻接矩阵存储时拓扑排序的时间复杂度为O(|V|2),深度优先搜索也可实现拓扑排序，判断图中是否有环 第六章 折半查找(二分查找)：仅适用于有序的顺序表，查找过程： ① 首先确定整个查找区间的中间位置 mid = (left + right)/2 。 ② 用待查关键字值与中间位置的关键字值进行比较；若相等，则查找成功；若大于，则在后（右）半个区域继续进行折半查找；若小于，则在前（左）半个区域继续进行折半查找。 ③ 对确定的缩小区域再按折半公式，重复上述步骤。最后，得到结果：要么查找成功， 要么查找失败。折半查找的存储结构采用一维数组存放 时间复杂度为O(log2n) 二叉排序树：二叉排序树本质是一棵二叉树，它的特别之处在于： 对于树中的每个结点，如果它有左子树，那么左子树上所有结点的值都比该结点小； 对于树中的每个结点，如果它有右子树，那么右子树上所有结点的值都比该结点大。 左右子树分别是一棵二叉排序树 删除过程： 若被删除节点是叶子节点，直接删除，不会破坏二叉排序树的性质 若被删除节点有一个左子树或者右子树，删除后让其子树代替 若被删除节点左右子树均不空，在右子树上找中序序列的第一个子女填补 二叉排序树的查找效率分析： 查找效率主要取决于树的高度 若输入序列是有序的，就是最坏情况下，其时间复杂度为O(n) 若变成平衡二叉树，查找时间复杂度就是O(log2n) 二叉排序树可作为二分查找的逻辑结构 平衡二叉树： 插入过程： LL型(单次右旋) RR型(单次左旋) LR型(先单次左旋，再单次右旋) RL型(先单次右旋，再单次左旋) 删除过程： 叶子节点直接删除 其他节点删除后要回溯到最靠近根节点的失衡节点进行调整，调整方法和插入一样 红黑树： 红黑树，本质上来说就是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n) 红黑树的性质： 1）每个结点要么是红的，要么是黑的。2）根结点是黑的。3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。4）不存在两个相邻的红节点。5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。 B树： 又称多路平衡查找树， 树中所有孩子结点个数的最大值称为该树的阶！树的阶数表示一个节点最多能有多少个子节点，也就是每个节点上最多的键值个数。比如二叉树的阶数就是2 根节点至少拥有两个子树，除了根节点之外的非叶子节点拥有K个子树以及K-1个元素((M+1/2) &lt; K &lt; M)，元素按照递增或递减顺序排列 所有叶子节点属于同一层 哈希表： 哈希函数的构造方法：直接定址法、除留余数法、数字分析法、平方取中法 处理哈希冲突的方法： 开放定址法：线性探测法、平方探测法、双散列法、伪随机序列法 拉链法 开放地址法如何删除关键字？（应该不是直接物理删除，做个标记虚拟删除） 哈希查找的效率取决于三个因素：散列函数、处理冲突的方法、装填因子 哈希查找的时间复杂度为O(1) 第七章 快速排序： 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 算法步骤：1．先从数列中取出一个数作为基准数。 2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 3．再对左右区间重复第二步，直到各区间只有一个数 算法代码： void quickSort(int a[],int left,int right)&#123; if(left&gt;right) return ; int i=left,j=right; int key=a[i]; while(i&lt;j)&#123; while(i&lt;j&amp;&amp;a[j]&gt;key) j--; while(i&lt;j&amp;&amp;a[i]&gt;key) i++; if(i&lt;j) swap(a[i],a[j]); &#125; swap(a[left],a[i]); quickSort(a,left,i-1); quickSort(a,i+1,right); &#125; 快速排序时间复杂度，平均时间复杂度的系数，答案是1.39 乱序的数中想要找到中间大小的值? 首先将数组的前（n+1）／2个元素建立一个最小堆。 然后，对于下一个元素，和堆顶的元素比较，如果小于等于，丢弃之，接着看下一个元素。如果大于，则用该元素取代堆顶，再调整堆，接着看下一个元素。重复这个步骤，直到数组为空。 当数组都遍历完了，那么，堆顶的元素即是中位数。 可以看出，长度为（n＋1）／2的最小堆是解决方案的精华之处。 堆排序： 是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。 如何调整堆？ 被删除元素用堆顶元素替代，然后该元素不断下坠。插入元素不断上浮 构造堆时，对第n除以2向下取整的节点所在子树筛选，调整好后，再调整它前一个节点，一直这样反复调整 输出堆顶元素后，将堆的最后一个元素与堆顶元素交换，再调整堆","categories":[{"name":"考研","slug":"考研","permalink":"http://example.com/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"考研复习","slug":"考研复习","permalink":"http://example.com/tags/%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/"}],"author":"zsk"},{"title":"刷题日记 day-4","slug":"刷题日记 day 4","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T11:07:28.694Z","comments":true,"path":"2021/09/24/刷题日记 day 4/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%204/","excerpt":"","text":"题目背景介绍今天写的是回溯算法解决的n皇后，在LeetCode上是第51题，难度是困难！ n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 首先来看一下皇后们的约束条件： 不能同行 不能同列 不能同斜线 唉，是个在二维数组上的回溯，这可咋整呢？ 代码实现class Solution &#123; List&lt;List&lt;String&gt;&gt; res=new ArrayList&lt;&gt;();//存放正确的结果集合 public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; char[][] chessboard=new char[n][n];//定义一个棋盘数组 //下面给棋盘数组赋值这个方式很轻巧，值得借鉴 for(char[] c:chessboard)&#123; Arrays.fill(c,&#39;.&#39;); &#125; backtracking(n,0,chessboard); return res; &#125; public void backtracking(int n,int row,char[][] chessboard)&#123; //函数参数row指的是棋盘的行数，也是递归树的深度 if(row==n)&#123; //当棋盘的行数等于n，就说明每一行都正确摆放了Q，可以加入正确的结果集合res res.add(new ArrayList&lt;&gt;(transform(chessboard))); return; &#125; for(int col=0;col&lt;n;++col)&#123; //这里的col指的是棋盘的列数，先判断当前棋盘的情况是不是满足要求 if(check(row,col,n,chessboard))&#123; chessboard[row][col]=&#39;Q&#39;;//处理棋盘 backtracking(n,row+1,chessboard); chessboard[row][col]=&#39;.&#39;;//回溯 撤销处理棋盘的操作 &#125; &#125; &#125; public List transform(char[][] chessboard)&#123; //这个函数是将字符二维数组转化为list List&lt;String&gt; path=new ArrayList&lt;&gt;(); for(char[] c:chessboard)&#123; path.add(String.copyValueOf(c)); &#125; return path; &#125; public boolean check(int row,int col,int n,char[][] chessboard)&#123; // 这个函数是检查棋盘的现状是否满足条件，主要从三个方面纵的方向不能有多个Q // 两个对角线上不能有多个Q for(int i=0;i&lt;n;i++)&#123; //检查列 if(chessboard[i][col]==&#39;Q&#39;) return false; &#125; for(int i=row-1,j=col-1;i&gt;=0&amp;&amp;j&gt;=0;i--,j--)&#123; //检查45度对角线 if(chessboard[i][j]==&#39;Q&#39;) return false; &#125; for(int i=row-1,j=col+1;i&gt;=0&amp;&amp;j&lt;=n-1;i--,j++)&#123; //检查135度对角线 if(chessboard[i][j]==&#39;Q&#39;) return false; &#125; return true; &#125; &#125; 分析与小结先来看看我画的递归树吧，这样讲的比较清晰。 可以看出来递归树的深度由棋盘的行数决定，每一层的情况由棋盘的列数决定。这也就是我们写题的着手方向。这个题比较需要注意的点在于这个图的建立，以及检查函数里对角线的排查，至于为啥不排查每一行的元素？这个你看图，每一行的Q都是独立的，所以不需要。这个不是我自己想出来的，是看别的大佬的题解。但弄懂以及把那个图画好也花了我不少时间。任重道远，仍需不断前行！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-10","slug":"刷题日记 day 10","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:28:49.570Z","comments":true,"path":"2021/09/24/刷题日记 day 10/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%2010/","excerpt":"","text":"写在前面​ 李奶奶的动态规划！！！真的觉得自己智商过低，不适合刷动态规划。于是我找了一个稍微简单一点的链表问题，题目来自于：**LeetCode 143. 重排链表**，这个题目的解法思路很多，我也想出来几种。但由于我对链表结构的不够熟悉，不能完美的利用链表结构特点，只能理解别人写的题解。题解的思路也很好理解： 找到链表的中点分割链表 将分割后的后半部分进行链表反转 将翻转后的链表和前半部分进行合并 题目的背景如下： 给定一个单链表 L 的头节点 head ，单链表 L 表示为： L0 → L1 → … → Ln-1 → Ln请将其重新排列后变为： L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → … 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 实例： 输入: head = [1,2,3,4]输出: [1,4,2,3] 输入: head = [1,2,3,4,5]输出: [1,5,2,4,3] 代码如下/** * Definition for singly-linked list. 这是关于链表结构的说明 * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */ class Solution &#123; public void reorderList(ListNode head) &#123; if(head.next==null||head.next.next==null) return ; ListNode fast=head; ListNode slow=head; //快慢指针 找到中点 //具体是快指针一次走两步 慢指针一次走一步 快指针走到头 慢指针走到链表中点 while(fast.next!=null&amp;&amp;fast.next.next!=null)&#123; fast=fast.next.next; slow=slow.next; &#125; ListNode newHead=slow.next; slow.next=null; newHead=reverse(newHead); while(newHead!=null)&#123; ListNode temp = newHead.next; newHead.next = head.next; head.next = newHead; head = newHead.next; newHead = temp; &#125; &#125; //反转链表 public ListNode reverse(ListNode head)&#123; ListNode pre=null; ListNode next=null; while(head!=null)&#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre; &#125; &#125; 写在后面​ 这个题目思路虽然不难想，但是实现有很多技巧，例如快慢指针、反转链表、合并链表这些小技巧，这都是阶梯模板。任重道远！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-5","slug":"刷题日记 day 5","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:14.981Z","comments":true,"path":"2021/09/24/刷题日记 day 5/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%205/","excerpt":"","text":"初探贪心算法​ 终于结束了回溯，老实说回溯是真的有点难，虽然有模板，但是很多问题的解决方式不尽相同。刷了也有20道题差不多，但是真正有印象的就几题。不过现在学到贪心了，我有点难受。它没有模板，就一个局部最优的算法思想。但是解决问题想到了这个思想，真的非常简单。想不到就呵呵了。 两个题目下面是我今天被贪心折磨的日常：LeetCode第53题 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums = [1]输出：1 示例 3： 输入：nums = [0]输出：0 示例 4： 输入：nums = [-1]输出：-1 示例 5： 输入：nums = [-100000]输出：-100000 提示： 1 &lt;= nums.length &lt;= 3 * 104-105 &lt;= nums[i] &lt;= 105 暴力解法 class Solution &#123; public int maxSubArray(int[] nums) &#123; int maxValue=Integer.MIN_VALUE; for(int i=0;i&lt;nums.length;i++)&#123; int count=0; for(int j=i;j&lt;nums.length;j++)&#123; count+=nums[j]; maxValue=count&gt;maxValue?count:maxValue; &#125; &#125; return maxValue; &#125; &#125; 时间复杂度是：O(n^2) 但是如果用贪心算法来写： class Solution &#123; public int maxSubArray(int[] nums) &#123; int maxValue=Integer.MIN_VALUE; int count=0; for(int i=0;i&lt;nums.length;i++)&#123; count+=nums[i]; if(count&gt;maxValue) maxValue=count; if(count&lt;0) count=0; &#125; return maxValue; &#125; &#125; 这个算法的时间复杂度很明显是O(n),初看还不是很明白，其实就是用了一个小技巧：我们都知道如果count后面加的是一个负数，就一定会让和变小，所以我们一旦碰到让count小于0的数据，就直接将count初始化为0，在从头开始记录count。这样看起来就使每一步都使得count是最大的，因为让count变成负数的元素我不会加入。这就是贪心的体现，但是这个很难想到呀！所以说贪心没有模板、只有一次次的踩坑积累经验，才可能想到有时候可以使用贪心。 LeetCode第55题 跳跃游戏给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。 示例 1： 输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。示例 2： 输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 提示： 1 &lt;= nums.length &lt;= 3 * 1040 &lt;= nums[i] &lt;= 105 这个题目就有点符合现实了，有点像跳台阶，其实可以从后往前跳，判断前一个节点是否能到达最后一个节点，如果可以就更新当前节点为最后一个节点。这是一种思路。但是贪心法更赖皮： class Solution &#123; public boolean canJump(int[] nums) &#123; int cover=0; if(nums.length==1) return true; for(int i=0;i&lt;=cover;i++)&#123; cover=Math.max(i+nums[i],cover); if(cover&gt;=nums.length-1) return true; &#125; return false; &#125; &#125; 看完也是不明所以，看了题解后感慨十分赖皮！其实就是看一个覆盖范围。你当前能走的步数的最大值是否覆盖到了最后一个元素，如果是肯定能走到。每次更新最大覆盖范围，这也是贪心法。 分析与小结做贪心的题目就感觉手上有本秘籍，很厉害。但是就是不会用，但是当你以为它就是废物时，丢掉了，别人捡起来，看了秘籍后成了你梦想成为的人。唉。任重而道远！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-7","slug":"刷题日记 day 7","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:24.428Z","comments":true,"path":"2021/09/24/刷题日记 day 7/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%207/","excerpt":"","text":"何为动态规划​ 动态规划就是Dynamic Programming，简称DP。如果解决一个问题需要解决它的很多重叠子问题，这个时候就需要用到动态规划。 ​ 动态规划的解题步骤： 确定dp数组以及下标的含义 确定递推公式 dp数组的初始化 确定遍历顺序 举例推导dp数组 题目背景今天写的第一题是我们的老熟题：509. 斐波那契数 。这个题目之前用的是递归，今天是动态规划。今天的第二题就有点难理解了：746. 使用最小花费爬楼梯。 代码如下 斐波那契数 class Solution &#123; public int fib(int n) &#123; if(n&lt;=1) return n; int[] dp=new int[n+1]; dp[0]=0; dp[1]=1; for(int i=2;i&lt;dp.length;i++)&#123; dp[i]=dp[i-1]+dp[i-2];//这个就是递推公式 &#125; return dp[n]; &#125; &#125; 使用最小花费爬楼梯 class Solution &#123; public int minCostClimbingStairs(int[] cost) &#123; int len=cost.length; int[] dp=new int[len]; dp[0]=cost[0]; dp[1]=cost[1]; for(int i=2;i&lt;len;i++)&#123; //递推关系式 dp[i]=Math.min(dp[i-1]+cost[i],dp[i-2]+cost[i]); &#125; return Math.min(dp[len-1],dp[len-2]); &#125; &#125; 分析与小结​ 从题解代码就可以很清楚的看出，dp数组的下标就表示第几个斐波那契数，而数组相对存储的就是第几个斐波那契数的值，递推公式题目也给了。所以解题十分方便。而第二题是斐波那契数列的变形，非常巧妙。我们每到达一个阶梯，都是从它的上一级或者上两级阶梯，所以当前花费最小将从它的上一级花费和上上一级花费之中诞生。这就是递推关系式： dp[i]=Math.min(dp[i-1]+cost[i],dp[i-2]+cost[i]);的由来。 ​ 今天的动态规划就到这里，持之以恒！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-1","slug":"刷题日记 Day01","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T09:00:34.973Z","comments":true,"path":"2021/09/24/刷题日记 Day01/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20Day01/","excerpt":"","text":"34. 在排序数组中查找元素的第一个和最后一个位置题目描述给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 主要思路仔细一看这就是二分查找的应用典型呀，虽然我知道要用二分查找，但是在做的时候还是没有一个明确的思路，搞了一晚上还是没能攻破，诶，看了题解以后就感觉好简单。分析一下我下面写的代码，防止以后再看的时候就看不懂了。 这个Solution包括三个函数，第一个就是主函数，第二个和第三个如名字一样，分别是寻找target在数组的第一个位置和最后一次出现的位置，二分查找的最重要的代码体就是： int left=0; int right=nums.length-1; while(left&lt;=right) &#123; int mid=left+(right-left)/2; if(nums[mid]&gt;target) right=mid-1; if(nums[mid]&lt;target) left=mid+1; &#125; return left; 注释1这个地方为啥多此一举 (right=mid-1;) ？这个是为了找到第一个出现target位置的操作，注释2这个地方加一个判断就是要搞清楚在数组里找没找到target，这两个地方都是针对这个题目做出的改变。 整体来说，就是利用二分查找在数组里找了两次target，分别找到第一个和最后一个出现target的位置。 代码如下class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int firstPosition=searchFirstPosition(nums,target); if(nums.length==0||firstPosition==-1) return new int[]&#123;-1,-1&#125;; int lastPosition=searchLastPosition(nums,target); return new int[]&#123;firstPosition,lastPosition&#125;; &#125; public int searchFirstPosition(int[] nums,int target)&#123; int left=0; int right=nums.length-1; while(left&lt;=right) &#123; int mid=left+(right-left)/2; if(nums[mid]==target)//注释1 right=mid-1; else if(nums[mid]&lt;target) left=mid+1; else right=mid-1; &#125; if(left!=nums.length&amp;&amp;nums[left]==target)//注释2 return left; else return -1; &#125; public int searchLastPosition(int[] nums,int target)&#123; int left=0; int right=nums.length-1; while(left&lt;=right) &#123; int mid=left+(right-left)/2; if(nums[mid]==target) left=mid+1; else if(nums[mid]&lt;target) left=mid+1; else right=mid-1; &#125; return right; &#125; &#125; 小结二分查找很有精神！！！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-6","slug":"刷题日记 day 6","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:19.641Z","comments":true,"path":"2021/09/24/刷题日记 day 6/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%206/","excerpt":"","text":"写在前面这两天被贪心折磨，贪心真的很难想到，初看题目有点看不懂，好不容易推演了两个测试，明白了题目的用意，但还是无从下手。一看题解代码和分析，就感觉自己是个傻zi。 今天写了两个贪心的题目，738. 单调递增的数字以及714. 买卖股票的最佳时机含手续费，这两题的代码都很简单，但都非常难想到。 代码如下 单调递增的数字 class Solution &#123; //解法一：暴力解法 很容易想到但是会超时 public int monotoneIncreasingDigits(int n) &#123; for(int i=n;i&gt;0;i--)&#123; if(check(i)) return i; &#125; return 0; &#125; public boolean check(int num)&#123; int max=10; while(num!=0)&#123; int t=num%10;//取出最后一位元素 if(t&lt;=max)&#123; max=t; &#125;else&#123; return false; &#125; num/=10; &#125; return true; &#125; &#125; class Solution &#123; /*解法二：从后往前遍历 n转化为字符数组a后 若a[i]&lt;a[i-1] 说明不是递增的 要进行调整 具体操作就是吧a[i-1]减一，以及把i以后的数字全部变成9，听起来很抽象。 如：n等于332 它的变化顺序是 332-&gt;329-&gt;299 这样经过两次调整就能得到正确结果，而且这 个算法时间复杂度是O(n). */ public int monotoneIncreasingDigits(int n) &#123; String s=String.valueOf(n);//转换成字符串更简单 int len=s.length(); int flag=len; char[] a=s.toCharArray(); for(int i=len-1;i&gt;=1;i--)&#123; if(a[i]&lt;a[i-1])&#123; flag=i; a[i-1]--; &#125; &#125; for(int i=flag;i&lt;len;i++)&#123; a[i]=&#39;9&#39;; &#125; return Integer.parseInt(new String(a)); &#125; &#125; 买卖股票的最佳时机含手续费 class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int minPay=prices[0]+fee; int sum=0; for(int i:prices)&#123; if(i+fee&lt;minPay) minPay=i+fee; else if(i&gt;minPay)&#123; sum+=i-minPay; minPay=i; &#125; &#125; return sum; &#125; &#125; 写在后面第二个题太难想到了，我也不想写啥分析，头晕。好在是终于结束了贪心(仓促)，明天动态规划！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-2","slug":"刷题日记day 2","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T10:25:23.584Z","comments":true,"path":"2021/09/24/刷题日记day 2/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0day%202/","excerpt":"","text":"写在前面好久没写博客了，虽然我的博客没人看，但是我觉得写博客是为了将自己的知识水平提高。写博客还可以让以后回顾知识变得更简单。之前一直没写主要是没啥兴趣，刷题在刚开始简直折磨，不夸张的说开始每一道题都是看答案的，有的看了答案也没弄懂，简直不知所云。对Java的集合类和数据结构也不是很熟悉，很多常用的方法函数不知道。经过20天左右的时间，我基本对刷题有一点的感觉了，开始越刷越快了。这个时候我想要慢下来，慢慢把刷的题总结一下。这就是再次写博客的理由。 题目概述及解法今天刷的还是回溯算法系列，这一题是：LeetCode第131题—分割回文串 题目的意思是：给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 回文串 是正着读和反着读都一样的字符串。 示例 1： 输入：s = “aab”输出：[[“a”,”a”,”b”],[“aa”,”b”]]示例 2： 输入：s = “a”输出：[[“a”]] 提示： 1 &lt;= s.length &lt;= 16s 仅由小写英文字母组成 解法代码：class Solution &#123; List&lt;List&lt;String&gt;&gt; res= new ArrayList&lt;&gt;();//存放正确结果的集合 Deque&lt;String&gt; path=new LinkedList&lt;&gt;();//存放单个正确结果(这里选择双端队列，若选择list删除时会出现错误) public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; backtracking(s,0); return res; &#125; public void backtracking(String s,int index)&#123;//回溯函数(也是递归函数) //确定回溯的终止条件(本题是： 当截取字符串的位置到达字符串最后一位就说明此次获取完成) if(index&gt;=s.length())&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; //for循环是解空间树的横向遍历，而回溯函数是解空间树的纵向遍历 for(int i=index;i&lt;s.length();i++)&#123; //先判断是否是回文串，是就截取放入path中，不是就跳过这次循环 if(isHuiWen(s,index,i))&#123; String str=s.substring(index,i+1); path.addLast(str); &#125;else&#123; continue; &#125; backtracking(s,i+1);//回溯函数(i+1是为了不再重复的截取) path.removeLast();//回溯 撤销之前处理节点的过程 &#125; &#125; //下面这个函数是判断是否是回文串 public boolean isHuiWen(String s,int index,int end)&#123; for(int i=index,j=end;i&lt;j;i++,j--)&#123; if(s.charAt(i)!=s.charAt(j)) return false; &#125; return true; &#125; &#125; 解法我在代码上做了详细的注释说明，主要就是截取字符串和数据结构Deque的选择。 写在后面虽然每天写的题不只一题，但是要是全部都记录下来，有点费时间，还是每天找一个喜欢的记录，这样也挺好的。 ​ 加油","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-3","slug":"刷题日记 day 9","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:35.658Z","comments":true,"path":"2021/09/24/刷题日记 day 9/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%209/","excerpt":"","text":"初识完全背包​ 完全背包是背包问题的变形之一，老实说01背包我也才半知半解，今天看题解也还是雾中看花。完全背包就是背包只有一个，但是物品可以重复放入无数次。即每种物品有无数件。 ​ 首先我们列出01背包的核心代码： for(int i=0;i&lt;weight.length;i++)&#123;//遍历物品 for(int j=bagWeight;j&gt;=weight[i];j--)&#123;//遍历背包容量 dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]); &#125; &#125; 01背包内嵌的for循环是从大到小遍历，为了保证每个物品仅被添加一次。 而完全背包的物品可以添加多次，所以内层循环是要从小到大： for(int i=0;i&lt;weight.length;i++)&#123;//遍历物品 for(int j=weight[i];j&lt;bagWeight;j++)&#123;//遍历背包容量 dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]); &#125; &#125; 两个小题第一题：518. 零钱兑换 II给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。 假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数 实例： 输入：amount = 5, coins = [1, 2, 5]输出：4解释：有四种方式可以凑成总金额：5=55=2+2+15=2+1+1+15=1+1+1+1+1 第二题：377. 组合总和 Ⅳ给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。 题目数据保证答案符合 32 位整数范围。 实例： 输入：nums = [1,2,3], target = 4输出：7解释：所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合 代码详解第一题class Solution &#123; public int change(int amount, int[] coins) &#123; int[] dp=new int[amount+1]; dp[0]=1; for(int i=0;i&lt;coins.length;i++)&#123;//遍历物品 for(int j=coins[i];j&lt;=amount;j++)&#123;//遍历背包 dp[j]+=dp[j-coins[i]]; &#125; &#125; return dp[amount]; &#125; &#125; 第二题class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; int[] dp=new int[target+1]; dp[0]=1; for(int i=0;i&lt;=target;i++)&#123;//遍历背包 for(int j=0;j&lt;nums.length;j++)&#123;//遍历物品 if(i-nums[j]&gt;=0)&#123; dp[i]+=dp[i-nums[j]]; &#125; &#125; &#125; return dp[target]; &#125; &#125; 分析与小结这个完全背包，这里有两种类型：组合和排列。 从代码可以看出来：组合问题for循环是先遍历物品，再遍历背包，而排列问题for循环先遍历背包，再遍历物品。 全是套路呀！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-8","slug":"刷题日记 day 8","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:29.558Z","comments":true,"path":"2021/09/24/刷题日记 day 8/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%208/","excerpt":"","text":"初探01背包问题​ 记得我第一次遇到01背包还是上学期，在算法课上听过老师讲动态规划和回溯的时候，当时觉得这个问题理解起来这么简单，为啥这么重要？当我开始想着写出它的代码。呵呵，一个菜鸡怎么可能会写代码呢。今天终于刷到了01背包问题，发现这个问题的原型是很简单不错，但是它的变形就不是那么容易看穿了。 ​ 一切的动态规划最重要的就是找递推关系式，在这个问题中。我们的动规数组**dp[j]**，的含义是啥呢？它表示：容量为j的背包所能容纳的最大的物品价值。它的递推公式是： **dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]);**因为背包外的物品只有两个选择：放入背包或者不放入。所以背包的价值也就在这两个状态里产生，不放就是dp[j]，放进去了，就是之前背包的价值加上这个物品的价值。非常好理解！ ​ 然后我们就要思考一下dp数组的初始化问题，很明显dp[0]肯定是0，因为背包内没有物品，自然也就没有最大价值一说了。 ​ 再者就要考虑一下遍历顺序，我们必须倒序遍历数组。这是因为：为了保证物品i只会被放入一次！ 例如：物品0的重量为weight[0]=1,其价值value[0]=15， 那么将它放入背包容量为1的情况下：dp[1]=dp[1-weight[0]]+value[0]=15 将它放入背包容量为2的情况下：dp[2]=dp[2-weight[0]]+value[0]=30; 这时就会发现放入容量为2的背包的时候，最大价值应该是15，但是正序遍历的结果是30，这就是因为物品0被重复放入了。 反之我们先放入容量为2背包，在放入容量为1的背包就不会出现这样的问题。 ​ 下面有两个背包问题的实例，请仔细揣摩： 两个问题问题一：416. 分割等和子集 题目背景：给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 题目实例： 输入：nums = [1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。 输入：nums = [1,2,3,5] 输出：false 解释：数组不能分割成两个元素和相等的子集。 问题二：1049. 最后一块石头的重量 II 题目背景：有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎；如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。 题目实例： 输入：stones = [2,7,4,1,8,1]输出：1解释：组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。 解决代码问题一class Solution &#123; public boolean canPartition(int[] nums) &#123; int sum=0; //初始化dp数组的容量 int[] dp=new int[200*100+1]; for(int i=0;i&lt;nums.length;i++)&#123; sum+=nums[i]; &#125; //如果不能分成完全相等的两堆或者说两个子集 就return false if(sum%2==1) return false; //我们的目标是在背包里尝试装入最大价值为sum/2的物品 int target=sum/2; for(int i=0;i&lt;nums.length;i++)&#123; //注意这里是逆向遍历 for(int j=target;j&gt;=nums[i];j--)&#123; //递推公式 老套路了 dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i]); &#125; &#125; /*最后这个判断很灵性：如果背包容量为target时的最大价值也为target 就说明是可以分为最大子集为原数组集合的一半*/ if(dp[target]==target) return true; return false; &#125; &#125; 问题二class Solution &#123; public int lastStoneWeightII(int[] stones) &#123; int sum=0; int[] dp=new int[30*100/2+1]; for(int x:stones)&#123; sum+=x; &#125; int target=sum/2; for(int i=0;i&lt;stones.length;i++)&#123; for(int j=target;j&gt;=stones[i];j--)&#123; dp[j]=Math.max(dp[j],dp[j-stones[i]]+stones[i]); &#125; &#125; return (sum-dp[target])-dp[target]; &#125; &#125; 小结与分析​ 问题一的思路主要就是：将原数组划分成两个最大的子集，两个子集的和是相等的就return true。就可以理解为将原数组的元素放入一个背包，看看背包的最大值是否能达到原数组的一半。具体分析过程就在代码注释里面。 ​ 问题二？ 看看代码不就会了？(狗头) 哈哈哈","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-3","slug":"刷题日记day 3","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:05.131Z","comments":true,"path":"2021/09/24/刷题日记day 3/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0day%203/","excerpt":"","text":"题目概述LeetCode第46题：全排列 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1： 输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]示例 2： 输入：nums = [0,1]输出：[[0,1],[1,0]]示例 3： 输入：nums = [1]输出：[[1]] 提示： 1 &lt;= nums.length &lt;= 6-10 &lt;= nums[i] &lt;= 10nums 中的所有整数 互不相同 解决代码class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();//存放正确结果的集合 List&lt;Integer&gt; path=new ArrayList&lt;&gt;();//存放单个正确的结果 public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; boolean[] used=new boolean[nums.length];//需要一个数组来判断集合的元素是否重复使用 backtracking(nums,used); return res; &#125; //子集问题和排列问题最大的不同，就是函数参数不再需要index，而是换成了boolean数组 public void backtracking(int[] nums,boolean[] used)&#123; //当path存放的元素到了全排列的数组的大小就可以停止，并传入res中 if(path.size()==nums.length)&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i=0;i&lt;nums.length;i++)&#123; //used数组就是记录path里面哪些元素已经被使用了，一个排列里元素只能使用一次 if(used[i]==true) continue; used[i]=true; path.add(nums[i]); backtracking(nums,used); path.remove(path.size()-1); used[i]=false; &#125; &#125; &#125; 分析小结这个题目是回溯算法的另一个擅长的拿手好戏，全排列和子集、组合问题的最大不同就是不需要传起始地址，因为每一层的元素可以重复使用，但是在一个分支里每个元素都只能用一次。下面是我画的一张解空间树的图，可以加深理解。 同时也想说，第一次使用画图工具，好难用，但是不用这个肯定画的又丑又难看懂。还是要继续努力，学习新知识！！！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"标签测试","slug":"标签测试","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:27:10.600Z","comments":true,"path":"2021/09/24/标签测试/","link":"","permalink":"http://example.com/2021/09/24/%E6%A0%87%E7%AD%BE%E6%B5%8B%E8%AF%95/","excerpt":"","text":"text带 下划线 的文本；带 着重号 的文本；带 波浪线 的文本；带 删除线 的文本 键盘样式的文本：⌘ + D 密码样式的文本：这里没有验证码 note这里可以是一段有用的希望能引人注意的信息 checkbox 纯文本测试 radio 纯文本测试 timeline2021-09-23 timeline测试 2021-09-22 1、 2021-09-21 2、 2021-09-23 3、 folding 这是一个折叠框 其他的还有好多元素实在太丰富了，我写个博客还用得着这么多？太看得起我了也hhh","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}],"author":"zsk"},{"title":"test","slug":"front-matter的测试","date":"2021-09-22T16:00:00.000Z","updated":"2023-02-25T04:09:11.178Z","comments":true,"path":"2021/09/23/front-matter的测试/","link":"","permalink":"http://example.com/2021/09/23/front-matter%E7%9A%84%E6%B5%8B%E8%AF%95/","excerpt":"","text":"this is a test!","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}],"author":"zsk"},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2021-09-22T10:51:47.372Z","updated":"2021-09-22T10:53:03.523Z","comments":true,"path":"2021/09/22/我的第一篇博客文章/","link":"","permalink":"http://example.com/2021/09/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"第一个标题第二个标题","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-09-22T10:34:25.959Z","updated":"2021-09-22T10:34:25.959Z","comments":true,"path":"2021/09/22/hello-world/","link":"","permalink":"http://example.com/2021/09/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"考研","slug":"考研","permalink":"http://example.com/categories/%E8%80%83%E7%A0%94/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"考研复习","slug":"考研复习","permalink":"http://example.com/tags/%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/"},{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]}
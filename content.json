{"meta":{"title":"zsk's personal blog","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-10-23T07:56:58.546Z","updated":"2021-09-23T14:01:53.223Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"关于 您正在与&nbsp;zsk&nbsp;对话中... bot_ui_ini()"},{"title":"","date":"2021-10-23T07:56:58.538Z","updated":"2021-09-23T04:38:02.126Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-10-23T07:56:58.546Z","updated":"2021-09-24T09:58:00.217Z","comments":false,"path":"artitalk/index.html","permalink":"http://example.com/artitalk/index.html","excerpt":"","text":""},{"title":"","date":"2021-10-23T07:56:58.546Z","updated":"2021-09-23T04:36:58.729Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-10-23T07:56:58.546Z","updated":"2021-09-23T04:35:53.515Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-10-23T07:56:58.546Z","updated":"2021-09-23T04:36:35.979Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构复习","slug":"数据结构复习","date":"2022-09-23T16:00:00.000Z","updated":"2023-02-25T05:13:25.539Z","comments":true,"path":"2022/09/24/数据结构复习/","link":"","permalink":"http://example.com/2022/09/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"数据结构第一章 逻辑结构分为线性结构和非线性结构 存储结构又被称为物理结构，主要有顺序存储、链式存储、索引存储、散列存储。 算法的五个重要特性：有穷性、确定性、可行性、输入、输出。 什么是时间复杂度：一个语句的执行次数被称为语句的频度，所有语句的频度之和记为**T(n)**，他是算法问题规模n的函数，时间复杂度主要就研究它的数量级。 $$T(n)=O(f(n))$$ 算法的时间复杂度不仅取决于问题的规模，而且取决于带输入数据的性质。 第二章 顺序表可以随机存取，而单链表只能顺序存取 头指针是指向链表第一个节点的指针,头结点是带头结点链表的第一个节点，节点内通常不存储信息。 引入头结点的两个好处：首先可以使链表第一个位置上的操作和其他位置一样，无需特殊处理，其次可以是使空表和非空表的处理统一起来 单链表的头插和尾插，头插法关键在于：s-&gt;next=L-&gt;next;L-&gt;next=s; 尾插法关键在于：LNode *r=L;r-&gt;next=s;r=s; 链表的删除操作：LNode *q=p-&gt;next;p-&gt;next=q-&gt;next;free(q); 如何快速找到一个单链表的三分之一处？ 答：可以使用双指针法，一个指针fast一次走三步，一个指针slow一次走一步，fast指针结束，返回slow指针的位置。 循环单链表的判空条件是它是否等于头指针，循环单链表不设头指针而仅设置尾指针，这样对表头和表尾的操作只需要O(1)的时间复杂度 静态链表：借助数组来描述线性表的链式存储结构，这里的指针是指节点的相对地址(数组下标)，在操作系统文件管理那里有个文件的显式链接的FAT文件分配表那里有应用。 第三章 循环队列： 初始时：Q.front=Q.rear=0; 进队：Q.rear=(Q.rear+1)%MaxSize 出队：Qfront=(Q.front+1)%MaxSize 队列长度：(Q.rear+MaxSize-Q.front)%MaxSize 队满条件:(Q.rear+1)%MaxSize==Q.front 队空条件：Q.front==Q.rear 为了区分队空和队满有三种处理方式： 牺牲一个存储单元来区分队空还是队满 增设表示数据元素个数的数据成员 增设tag数据成员，tag为0则队空，tag为1则队满 双端队列：允许两端都可以入队和出队的队列 第四章 树中的节点数等于所有节点的度数之和加一 完全二叉树：一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。 特点是：叶子节点只会出现在最后两层；节点编号i若小于等于n/2向下取整，则为分支节点，否则为叶子结点；若存在度为1的节点，那么这个节点有且只能有一个；且该节点只有左孩子无右孩子； 二叉树的性质： 非空二叉树的叶子结点数等于度为2的节点数加一 非空二叉树第k层上至多有2的k-1次方个节点 高度为h的二叉树至多有2的h次方减一个节点 二叉树的遍历，后序遍历的非递归算法中必须使用到栈，层次遍历需要用到队列。 线索二叉树：在n个节点的二叉树中有n+1个空指针，引入线索二叉树就是为了加快查找节点前驱和后继的速度 树：树的三种常用存储结构： 双亲表示法：就是静态链表类似的结构 孩子表示法：拉链法 孩子兄弟表示法：还是二叉树，只不过变成了左孩子右兄弟 树、二叉树和森林的转换 树转换成二叉树的规则是左孩子右兄弟。森林转换成二叉树的规则是先把森林中的每棵树转换成二叉树，再把它们的根视为兄弟关系连接起来。将二叉树转换成森林的规则是把根的右链断开。 树的先根遍历和后根遍历对应二叉树的先序遍历和中序遍历 WPL(带权路径长度)：从根出发到任意节点的路径长度与该点权值的乘积，称为该节点的带权路径长度。所有叶节点的带权路径长度之和称为树的WPL，在哈夫曼树中WPL等于所有非叶结点的权值之和 哈夫曼树: 在含有n个带权叶节点的二叉树中，WPL最小的称为哈夫曼树。(哈夫曼树中不存在度为1的节点) 哈夫曼编码：是可变字长编码的一种，利用哈夫曼树可以设计出总长度最短的二进制前缀编码。 哈夫曼编码的应用：数据压缩、文件压缩、图像编码处理 第五章 简单图：不存在重复边；不存在顶点到自身的边 完全图：对于无向图，边的取值范围是0到n(n-1)/2,对于有向图，边的取值范围是0到**n(n-1)** 连通分量:无向图的极大连通子图 强连通分量：有向图的极大强连通子图 生成树：包含图中所有顶点的极小连通子图 无向图的全部顶点的度之和等于边数的两倍；有向图的全部顶点的入度之和和出度之和相等且等于边数 若一个图有n个顶点，并且有大于n-1条边，则此图一定有环 图的邻接矩阵： 无向图的邻接矩阵一定是一个对称矩阵，并且唯一。实际存储只需要存储上(下)三角矩阵的元素 对于无向图，邻接矩阵第i行非零元素的个数刚好是该顶点的度 对于有向图，邻接矩阵第i行非零元素的个数刚好是该顶点的出度；邻接矩阵第j列非零元素的个数刚好是该顶点的入度 稠密图适合邻接矩阵，稀疏图适合邻接表 图的邻接表： 在有向图的邻接表表示法中，求给定顶点的出度只需计算邻接表中结点的个数，但求其顶点的入度需要遍历全部的邻接表。 邻接表中存在两种节点，顶点表节点和边表节点 **广度优先搜索(BFS)**：类似于二叉树的层序遍历,是一种分层查找过程，它不是一个递归算法，为了实现逐层访问，必须借助一个辅助队列，记忆正在访问节点的下一层节点。时间复杂度为O(|V|的平方),空间复杂度为O(|V|),使用BFS可以求非带权图(或者权值一样)的单源最短路径，这是由BFS总是按照距离从近到远遍历图中每个顶点决定的 **深度优先搜索(DFS)**：类似于二叉树的先序遍历，DFS是一个递归算法，需要借助递归工作栈，时间复杂度为O(|V|+|E|),空间复杂度为O(|V|) 图的遍历算法可以判断图的连通性 无向连通图最多几条边，最少几条? 答：最多n*(n-1)/2,最少n-1 最小生成树：给定一个带有权值的连通图（连通网），从众多的生成树中筛选出权值总和最小的生成树，即为该图的最小生成树 一般来说最小生成树不唯一，但当带权连通图中任意一个环所包含的边的权值均不相同时，其MST是唯一的。 最小生成树边的权值之和总是唯一的，其边数为顶点数减一。 Prim算法和Kruskal算法的区别： 最短路径：带权路径长度最短的那条路径称为最短路径。 广度优先算法求解最短路径针对无权图(或者权值一样)而言，求带权有向图一般两种算法：迪杰斯特拉算法和弗洛伊德算法。 迪杰斯特拉算法基于贪心策略，求源点到某个特定顶点的最短路径和到其他所有顶点的最短路径一样复杂，时间复杂度都为O(|V|2),当边上带有负权值时，迪杰斯特拉算法并不适用 弗洛伊德算法时间复杂度为O(|V|3)，允许图中带有负权值的边，但不允许带有负权值边的回路 拓扑排序：使用邻接表存储时拓扑排序的时间复杂度为O(|V|+|E|)，实用邻接矩阵存储时拓扑排序的时间复杂度为O(|V|2),深度优先搜索也可实现拓扑排序，判断图中是否有环 第六章 折半查找(二分查找)：仅适用于有序的顺序表，查找过程： ① 首先确定整个查找区间的中间位置 mid = (left + right)/2 。 ② 用待查关键字值与中间位置的关键字值进行比较；若相等，则查找成功；若大于，则在后（右）半个区域继续进行折半查找；若小于，则在前（左）半个区域继续进行折半查找。 ③ 对确定的缩小区域再按折半公式，重复上述步骤。最后，得到结果：要么查找成功， 要么查找失败。折半查找的存储结构采用一维数组存放 时间复杂度为O(log2n) 二叉排序树：二叉排序树本质是一棵二叉树，它的特别之处在于： 对于树中的每个结点，如果它有左子树，那么左子树上所有结点的值都比该结点小； 对于树中的每个结点，如果它有右子树，那么右子树上所有结点的值都比该结点大。 左右子树分别是一棵二叉排序树 删除过程： 若被删除节点是叶子节点，直接删除，不会破坏二叉排序树的性质 若被删除节点有一个左子树或者右子树，删除后让其子树代替 若被删除节点左右子树均不空，在右子树上找中序序列的第一个子女填补 二叉排序树的查找效率分析： 查找效率主要取决于树的高度 若输入序列是有序的，就是最坏情况下，其时间复杂度为O(n) 若变成平衡二叉树，查找时间复杂度就是O(log2n) 二叉排序树可作为二分查找的逻辑结构 平衡二叉树： 插入过程： LL型(单次右旋) RR型(单次左旋) LR型(先单次左旋，再单次右旋) RL型(先单次右旋，再单次左旋) 删除过程： 叶子节点直接删除 其他节点删除后要回溯到最靠近根节点的失衡节点进行调整，调整方法和插入一样 红黑树： 红黑树，本质上来说就是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n) 红黑树的性质： 1）每个结点要么是红的，要么是黑的。2）根结点是黑的。3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。4）不存在两个相邻的红节点。5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。 B树： 又称多路平衡查找树， 树中所有孩子结点个数的最大值称为该树的阶！树的阶数表示一个节点最多能有多少个子节点，也就是每个节点上最多的键值个数。比如二叉树的阶数就是2 根节点至少拥有两个子树，除了根节点之外的非叶子节点拥有K个子树以及K-1个元素((M+1/2) &lt; K &lt; M)，元素按照递增或递减顺序排列 所有叶子节点属于同一层 哈希表： 哈希函数的构造方法：直接定址法、除留余数法、数字分析法、平方取中法 处理哈希冲突的方法： 开放定址法：线性探测法、平方探测法、双散列法、伪随机序列法 拉链法 开放地址法如何删除关键字？（应该不是直接物理删除，做个标记虚拟删除） 哈希查找的效率取决于三个因素：散列函数、处理冲突的方法、装填因子 哈希查找的时间复杂度为O(1) 第七章 快速排序： 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 算法步骤：1．先从数列中取出一个数作为基准数。 2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 3．再对左右区间重复第二步，直到各区间只有一个数 算法代码： void quickSort(int a[],int left,int right)&#123; if(left&gt;right) return ; int i=left,j=right; int key=a[i]; while(i&lt;j)&#123; while(i&lt;j&amp;&amp;a[j]&gt;key) j--; while(i&lt;j&amp;&amp;a[i]&gt;key) i++; if(i&lt;j) swap(a[i],a[j]); &#125; swap(a[left],a[i]); quickSort(a,left,i-1); quickSort(a,i+1,right); &#125; 快速排序时间复杂度，平均时间复杂度的系数，答案是1.39 乱序的数中想要找到中间大小的值? 首先将数组的前（n+1）／2个元素建立一个最小堆。 然后，对于下一个元素，和堆顶的元素比较，如果小于等于，丢弃之，接着看下一个元素。如果大于，则用该元素取代堆顶，再调整堆，接着看下一个元素。重复这个步骤，直到数组为空。 当数组都遍历完了，那么，堆顶的元素即是中位数。 可以看出，长度为（n＋1）／2的最小堆是解决方案的精华之处。 堆排序： 是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。 如何调整堆？ 被删除元素用堆顶元素替代，然后该元素不断下坠。插入元素不断上浮 构造堆时，对第n除以2向下取整的节点所在子树筛选，调整好后，再调整它前一个节点，一直这样反复调整 输出堆顶元素后，将堆的最后一个元素与堆顶元素交换，再调整堆","categories":[{"name":"考研","slug":"考研","permalink":"http://example.com/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"考研复习","slug":"考研复习","permalink":"http://example.com/tags/%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/"}],"author":"zsk"},{"title":"操作系统复习","slug":"操作系统复习","date":"2022-05-13T16:00:00.000Z","updated":"2023-02-27T07:45:19.439Z","comments":true,"path":"2022/05/14/操作系统复习/","link":"","permalink":"http://example.com/2022/05/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"重点问题 什么是操作系统，它有哪些功能和特征 操作系统(operating system)，是管理和控制计算机软硬件资源的程序。是直接运行在裸机上的最基本的系统软件。任何软件都需要操作系统的支持。 操作系统可以进行处理机管理、存储器管理、设备管理、文件管理 操作系统控制管理软硬件及数据资源，控制程序运行、改善人机交互界面，按照程序的请求分配资源 操作系统的特征： 并发 同一时间间隔 共享 进程共享系统的资源 虚拟 把物理实体变成逻辑对应物 异步 进程的执行不是一走到底，而是走走停停，以不可预知的速度向前推进 详细说说操作系统的管理功能 处理机管理：进程控制、进程同步、进程通信、进程调度 存储管理：内存分配、内存保护、内存扩充、地址映射 设备管理：缓冲管理、设备分配、设备处理程序 文件管理：文件存储空间的管理、目录管理、文件的读写管理和保护 操作系统的发展过程 手工阶段，无操作系统，计算机的所有工作都需要人工干预，CPU利用率低 单道批处理系统，在主机和输入机之间增加一个存储设备—-磁带机，提高了计算机资源的利用率，但每次内存中仅存放一道作业 多道批处理系统，允许多个程序同时进入内存并运行，不提供人机交互能力，不利于用户操作 分时操作系统，把处理机的运行时间分很短时间片，按时间片轮流把处理及分配给作业使用 实时操作系统分为软实时和硬实时，硬实时是飞机、导弹自动控制，软实时预定飞机票查询航班 网络操作系统和分布式操作系统 什么是管态和目态， 管态又被称为特权态和核心态，CPU在管态可以执行指令系统的全集，可以访问系统的所有资源 目态又称用户态，只能执行非特权指令，不能改变CPU的状态，只能访问当前程序的存储空间 区分管态和目态的目的是为了保护操作系统程序，内核程序不允许用户直接执行 怎么从用户态切换到管态？ 系统调用 异常 I/O设备的中断 系统调用是进程主动发起的，而异常和中断是被动地 进程和线程的区别？ 线程就是轻量级进程，它是CPU调度的基本执行单元，由线程ID、程序计数器、寄存器集合、堆栈组成，线程属于进程 进程是资源分配和调度的基本单位，线程是CPU调度的基本单元 进程里面可以有多个线程，线程共享进程内的资源 进程的创建使用fork和vfork，而线程的创建使用pthread_create； 进程间的通信方式有哪些？ 共享内存模式 在通信进程之间存在一块直接访问的共享空间 消息传递模式 进程必须使用系统提供的发送消息和接收消息两个原语 又称信箱通信 共享文件模式 连接一个读进程和一个写进程以实现它们之间通信的文件就是共享文件，又称pipe管道文件 高级调度和低级调度的区别？以及什么是中级调度？ 高级调度称为作业调度，是根据某种算法，把外存上处于后备队列的作业调入内存 低级调度称为进程调度，根据某种算法就绪队列的进程分配处理机 中级调度主要目的是提高内存的利用率和系统吞吐量，将暂时不能运行的进程调至外存等待，将进程的状态改为挂机状态 常见的调度算法？ FCFS(从先来先服务) 按照进入系统先后的次序调度，有利于CPU繁忙型进程，不利于IO繁忙型进程，对短作业不利 SJF(短作业优先) 挑选运行时间最短的进程先上处理机，对长作业不利，容易使其饥饿 优先级调度算法，又分为抢占式和非抢占式 高响应比优先调度算法，响应比等于(等待时间+要求服务时间)/要求服务时间克服了饥饿状态 时间片轮转算法 主要适用于分时系统的调度，若时间片太大，则会退化成先来先服务，若时间片太小，则会频繁切换上下文，频繁中断，增加系统开销 多级反馈队列调度算法 设置多个就绪队列，并赋予优先级，优先级越高，时间片越小。仅当高优先级队列中无就绪进程才开始调度低优先级队列的进程 什么是死锁？为什么会产生死锁？怎么解决死锁？ 死锁是指多个进程因竞争资源而造成互相等待，无法向前推进的局面。 产生死锁的原因有竞争资源和推进顺序非法 死锁产生的必要条件： 互斥 请求和保持 进程本身占有资源又去请求其他资源 不可剥夺 循环等待 存在一种进程等待循环链 解决死锁的方法有： 预防死锁 破坏死锁产生的必要条件 避免死锁 银行家算法 死锁的监测与解除 检测使用资源分配图 解除可以进程回退、撤销进程 什么是动态重定位？怎么实现？ 动态重定位是指将访问的程序和数据的逻辑地址转换成物理地址 具体实现方法是加一个重定位寄存器，装入程序在内存的起始地址，程序执行的时候，访问的是相对地址加上重定位寄存器的地址 分区存储管理有哪些分配策略？优缺点 首次适应算法 按地址从小到大排序 每次分配从低地址查找 循环首次适应算法 从上次结束的位置查找 最佳适应算法 按空间大小排序 每次分配最小的符合条件的分区 会留下许多小的难以利用的空闲区 最坏适应算法 按空间大小排序 每次分配最小、大的符合条件的分区 在具有快表的段页式存储管理方式中，如何实现地址变换？ CPU给出有效地址后，地址变换机构自动把页号送入快表，若匹配，说明访问页面在快表中，从快表中读出物理块号。否则，利用页号查询页表，把页表内的物理块号送入地址寄存器，同时修改快表，若寄存器满，则考虑使用什么算法换出页面 分段和分页有什么异同？ 相同点：分页和分段都是离散分配方式，都需要地址变换机构 不同点：页是物理单位，段是逻辑单位。页面的大小是由系统决定的，且固定不变。段的大小是由用户决定的。分页的地址空间是一维的，分段的地址空间是二维的 什么是局部性原理？什么是虚拟存储器？ 局部性原理分两个方面，时间局部性和空间局部性 时间局部性是指某条指令执行不久后会再次执行，某个数据使用后会再次使用，原因是程序存在大量的循环操作 空间局部性是指某个存储单元被访问不久后其附近的存储单元可能被访问，原因是指令通常是顺序存放的，数据一般也以数组聚集存放 虚拟存储器是指具有调入和置换功能，逻辑上对内存进行扩充的一种存储系统。基于局部性原理，在程序装入时，仅仅装入一部分，就可以驱动程序执行，在程序执行过程中，访问的内容不在内存时，操作系统负责将其调入内存。同时操作系统将用不到的内存调出内存。这样在逻辑上扩充的内存的容量 有哪些页面置换算法？什么是抖动 最佳置换算法：将以后最长时间不使用的页面调出，无法实现 先进先出置换算法：贝乐迪异常 最近最久未使用算法 clock置换算法：每个页面设置一个使用位和修改位 抖动就是页面置换过程中，频繁的换入换出 有哪些常用的文件分配方式? 连续分配，实现简单，存取速度快。文件长度不宜动态增加 链接分配，分为显式链接和隐式链接 显式链接：把用于链接各个物理块的指针提取出来，显示的放在一张表里，这个表就是FAT文件分配表 隐式链接：每个磁盘块对应一个磁盘块的链表，每个块都有指向下一个块的指针 索引分配，把文件的所有盘块号组成一张索引表 单级索引分配 多级索引分配 混合索引分配 常见的磁盘调度算法 先来先服务 短作业优先 会产生饥饿现象 扫描算法 在磁头当前移动方向上选择与当前磁头距离最近的磁道 循环扫描算法 到达磁盘端点或最远端点请求快速返回起始端 有哪几种IO控制方式 程序查询方式 CPU对外设不断地轮巡检查 CPU和IO只能串行工作 CPU利用率相当低 中断方式 允许IO设备主动请求CPU的服务，在CPU完成后可以继续其手头上的工作 DMA方式 在IO设备和内存之间直接开辟数据交换通路，数据交换的基本单位是数据块，仅在开始和结束是CPU介入，数据传送由DMA控制器控制完成 通道方式 是DMA的发展，IO通道专门负责输入输出的处理机 引入缓冲区的目的是什么 缓和CPU和IO设备速度不匹配的矛盾 减少CPU中断频率 提高CPU与IO设备的并行性 什么是SPOOLing技术(假脱机)？ 由哪几部分组成？举出一个应用它的实例？ 是慢字符设备和主机交换信息的一种技术，由主机和通道共同参加作业的输入输出工作，是操作系统中一种将独占设备改造成共享设备的技术 由三个部分组成： 输入井输出井 输入缓冲和输出缓冲 输入进程和输出进程 提高了IO速度，将独占设备改造为共享设备，实现了虚拟设备功能 将一台独享的打印机改造为共享的打印机就是应用此技术的典例 具体做法是：不把真正的打印机分配给用户进程，而是在输出井中开辟一块空闲盘块区，将要打印的数据输入其中，为用户申请打印请求，排成队列，若打印机空闲，从队列头部取出打印请求并打印 解释下微内核？ 对宏内核架构的操作系统进行解耦，将单个功能或模块（如文件系统、设备驱动等）从内核中拆分出来，作为一个独立的服务部署到独立的运行环境中；内核仅保留极少的功能，为这些服务提供通信等基础能力，使其能够互相协作以完成操作系统所必需的功能。这种架构被称为微内核","categories":[{"name":"考研","slug":"考研","permalink":"http://example.com/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"考研复习","slug":"考研复习","permalink":"http://example.com/tags/%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/"}],"author":"zsk"},{"title":"C语言复习","slug":"C语言复习","date":"2022-03-22T16:00:00.000Z","updated":"2023-02-26T13:23:46.834Z","comments":true,"path":"2022/03/23/C语言复习/","link":"","permalink":"http://example.com/2022/03/23/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"重点问题 c和c++的区别？ 首先c语言是面向过程的语言，而c++是面向对象的语言 编写c语言程序就是分析解决问题的步骤，之后一步步实现这些步骤，这些步骤写成函数，依次调用即可。而使用c++编写程序的思路是把问题拆分成各个对象，描述对象在解决问题时的行为 具体语言的区别体现在几个方面： 关键字个数不同，c是37个，c++是63个 返回值不同，c语言默认返回int类型的值，c++若没有返回值类型必须定义为void c语言没有重载函数，c++的函数重载允许声明同名函数但形参的顺序或返回值可以不同 其代表的面向对象和面向过程的优缺点： 面向过程是：性能高，但是开销大，消耗资源，不易于维护和拓展 面向对象是：性能低，但是易于维护和扩展，编程灵活，可以设计出低耦合的系统 描述一下gcc编译过程 一共有四步：预处理、编译、汇编、链接 预处理：头文件包含、宏替换、条件编译、注释删除 编译：主要进行语法、词法、语义分析，将预处理好的文件编译成汇编文件 汇编：将汇编文件转换成二进制目标文件 链接：将二进制文件加上所需的库以及启动代码连接成可执行文件 什么是预编译： 预编译又称预处理，是编译过程中最先做的事，主要处理#开头的指令，比如拷贝#include的代码，替换宏定义#define 传值、传地址和引用的区别 传值：会重新分配空间给形参，把实参的值拷贝给形参，形参的修改不会改变实参的值，函数调用结束后，形参就被释放 传地址：在这种传递过程中，形参是指针类型的变量，实参是变量的地址，被调用函数中对形参指针所指向的地址中内容的任何改变都会影响到实参 引用：引用和原变量是同一个东西，只不过是原变量的一个别名。在被调用函数中，对引用变量的所有操作等价于对实参的操作。这样，整个函数执行完毕后，原先的实参的值将会发生改变。 传递引用给函数与传递指针的效果是一样的 关键字static的作用？ 用于局部变量的修饰符；当 static 用于修饰局部变量时，通常是在某个函数体内，只能在该函数内被调用。这样定义的变量通常被称为局部静态变量，它的值不会因为函数调用的结束而被清除，当函数再次被调用时，它的值是上一次调用结束后的值。 用于全局变量的修饰符；静态全局变量的存储位置、初始化操作同静态局部变量的特性，但其作用域有所不同：静态全局变量可以被该文件内的所有函数访问，但不能被其它文件内的函数访问。 用于函数的修饰符。静态函数的作用域仅限于本文件，不能被其它文件调用。 结构体和类的区别是什么？ 结构体是存放很多数据的结构，里面不含有对数据的操作，而类里面可以封装对数据的操作 类对成员变量有访问权限，结构体没有，结构体外可以任意访问结构体内的成员，但类外的不能访问定义为private成员 结构体在堆栈中创建是值类型，而类是引用类型 break和continue的区别？ break是终止整个循环过程，不再判断循环条件是否成立 continue是结束本次循环过程，且continue只能在循环语句中使用，break在Switch语句可以使用 C语言运算符的优先级 简单记就是：！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符 优先级 运算符 名称或含义 使用形式 结合方向 说明 1 [] 数组下标 数组名[常量表达式] 左到右 – () 圆括号 (表达式）/函数名(形参表) – . 成员选择（对象） 对象.成员名 – -&gt; 成员选择（指针） 对象指针-&gt;成员名 – 2 - 负号运算符 -表达式 右到左 单目运算符 ~ 按位取反运算符 ~表达式 ++ 自增运算符 ++变量名/变量名++ – 自减运算符 –变量名/变量名– * 取值运算符 *指针变量 &amp; 取地址运算符 &amp;变量名 ! 逻辑非运算符 !表达式 (类型) 强制类型转换 (数据类型)表达式 – sizeof 长度运算符 sizeof(表达式) – 3 / 除 表达式/表达式 左到右 双目运算符 * 乘 表达式*表达式 % 余数（取模） 整型表达式%整型表达式 4 + 加 表达式+表达式 左到右 双目运算符 - 减 表达式-表达式 5 &lt;&lt; 左移 变量&lt;&lt;表达式 左到右 双目运算符 &gt;&gt; 右移 变量&gt;&gt;表达式 6 &gt; 大于 表达式&gt;表达式 左到右 双目运算符 &gt;= 大于等于 表达式&gt;=表达式 &lt; 小于 表达式&lt;表达式 &lt;= 小于等于 表达式&lt;=表达式 7 == 等于 表达式==表达式 左到右 双目运算符 ！= 不等于 表达式!= 表达式 8 &amp; 按位与 表达式&amp;表达式 左到右 双目运算符 9 ^ 按位异或 表达式^表达式 左到右 双目运算符 10 | 按位或 表达式|表达式 左到右 双目运算符 11 &amp;&amp; 逻辑与 表达式&amp;&amp;表达式 左到右 双目运算符 12 || 逻辑或 表达式||表达式 左到右 双目运算符 13 ?: 条件运算符 表达式1?表达式2: 表达式3 右到左 三目运算符 14 = 赋值运算符 变量=表达式 右到左 – /= 除后赋值 变量/=表达式 – *= 乘后赋值 变量*=表达式 – %= 取模后赋值 变量%=表达式 – += 加后赋值 变量+=表达式 – -= 减后赋值 变量-=表达式 – &lt;&lt;= 左移后赋值 变量&lt;&lt;=表达式 – &gt;&gt;= 右移后赋值 变量&gt;&gt;=表达式 – &amp;= 按位与后赋值 变量&amp;=表达式 – ^= 按位异或后赋值 变量^=表达式 – |= 按位或后赋值 变量|=表达式 – 15 ， 逗号运算符 表达式,表达式,… 左到右 – C语言的内存分配 在C语言中，定义了4个内存区间：代码区；全局变量与静态变量区；局部变量区即栈区；动态存储区，即堆区。下面分别对这4个区进行介绍。① 代码区。代码区中主要存放程序中的代码，属性是只读的。② 全局变量与静态变量区。也称为静态存储区域。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如：全局变量、静态变量和字符串常量。分配在这个区域中的变量，当程序结束时，才释放内存。因此，经常利用这样的变量，在函数间传递信息。③ 栈区。在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。在linux系统中，通过命令“ulimit –s”，可以看到，栈的容量为8192kbytes，即8M。 这种内存方式，变量内存的分配和释放都自动进行，程序员不需要考虑内存管理的问题，很方便使用。但缺点是，栈的容量有限制，且当相应的范围结束时，局部变量就不能在使用。④ 堆区。有些操作对象只有在程序运行时才能确定，这样编译器在编译时就无法为他们预先分配空间，只能在程序运行时分配，所以称为动态分配。 C语言里面main函数有什么参数？分别有什么作用？ 第一个参数 argc ，用于存放命令行参数的个数。第二个参数 argv，是个字符指针的数组，每个元素都是一个字符指针，指向一个字符串，即命令行中的每一个参数。第三个参数 envp ,也是一个字符指针的数组，这个数组的每一个元素是指向一个环境变量的字符指针。 任何类型的指针变量都是占用4个字节 指针即为地址，指针几个字节跟语言无关，而是跟系统的寻址能力有关，譬如以前是16为地址，指针即为2个字节，现在一般是32位系统，所以是4个字节，以后64位，则就为8个字节 函数指针和回调函数： #include &lt;stdio.h&gt; int max(int x, int y) &#123; return x &gt; y ? x : y; &#125; int main(void) &#123; /* p 是函数指针 */ int (* p)(int, int) = &amp; max; // &amp;可以省略 int a, b, c, d; printf(&quot;请输入三个数字:&quot;); scanf(&quot;%d %d %d&quot;, &amp; a, &amp; b, &amp; c); /* 与直接调用函数等价，d = max(max(a, b), c) */ d = p(p(a, b), c); printf(&quot;最大的数字是: %d\\n&quot;, d); return 0; &#125; 函数指针作为某个函数的参数函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。 typedef和#define的区别 typedef是一种声明自定义数据类型的关键字，在编译阶段有效，故可以进行类型检查 #define是预处理指令，发生在编译之前，只进行替换而不做检查","categories":[{"name":"考研","slug":"考研","permalink":"http://example.com/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"考研复习","slug":"考研复习","permalink":"http://example.com/tags/%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/"}],"author":"zsk"},{"title":"刷题日记 day-1","slug":"刷题日记 Day01","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T09:00:34.973Z","comments":true,"path":"2021/09/24/刷题日记 Day01/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20Day01/","excerpt":"","text":"34. 在排序数组中查找元素的第一个和最后一个位置题目描述给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 主要思路仔细一看这就是二分查找的应用典型呀，虽然我知道要用二分查找，但是在做的时候还是没有一个明确的思路，搞了一晚上还是没能攻破，诶，看了题解以后就感觉好简单。分析一下我下面写的代码，防止以后再看的时候就看不懂了。 这个Solution包括三个函数，第一个就是主函数，第二个和第三个如名字一样，分别是寻找target在数组的第一个位置和最后一次出现的位置，二分查找的最重要的代码体就是： int left=0; int right=nums.length-1; while(left&lt;=right) &#123; int mid=left+(right-left)/2; if(nums[mid]&gt;target) right=mid-1; if(nums[mid]&lt;target) left=mid+1; &#125; return left; 注释1这个地方为啥多此一举 (right=mid-1;) ？这个是为了找到第一个出现target位置的操作，注释2这个地方加一个判断就是要搞清楚在数组里找没找到target，这两个地方都是针对这个题目做出的改变。 整体来说，就是利用二分查找在数组里找了两次target，分别找到第一个和最后一个出现target的位置。 代码如下class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int firstPosition=searchFirstPosition(nums,target); if(nums.length==0||firstPosition==-1) return new int[]&#123;-1,-1&#125;; int lastPosition=searchLastPosition(nums,target); return new int[]&#123;firstPosition,lastPosition&#125;; &#125; public int searchFirstPosition(int[] nums,int target)&#123; int left=0; int right=nums.length-1; while(left&lt;=right) &#123; int mid=left+(right-left)/2; if(nums[mid]==target)//注释1 right=mid-1; else if(nums[mid]&lt;target) left=mid+1; else right=mid-1; &#125; if(left!=nums.length&amp;&amp;nums[left]==target)//注释2 return left; else return -1; &#125; public int searchLastPosition(int[] nums,int target)&#123; int left=0; int right=nums.length-1; while(left&lt;=right) &#123; int mid=left+(right-left)/2; if(nums[mid]==target) left=mid+1; else if(nums[mid]&lt;target) left=mid+1; else right=mid-1; &#125; return right; &#125; &#125; 小结二分查找很有精神！！！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-10","slug":"刷题日记 day 10","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:28:49.570Z","comments":true,"path":"2021/09/24/刷题日记 day 10/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%2010/","excerpt":"","text":"写在前面​ 李奶奶的动态规划！！！真的觉得自己智商过低，不适合刷动态规划。于是我找了一个稍微简单一点的链表问题，题目来自于：**LeetCode 143. 重排链表**，这个题目的解法思路很多，我也想出来几种。但由于我对链表结构的不够熟悉，不能完美的利用链表结构特点，只能理解别人写的题解。题解的思路也很好理解： 找到链表的中点分割链表 将分割后的后半部分进行链表反转 将翻转后的链表和前半部分进行合并 题目的背景如下： 给定一个单链表 L 的头节点 head ，单链表 L 表示为： L0 → L1 → … → Ln-1 → Ln请将其重新排列后变为： L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → … 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 实例： 输入: head = [1,2,3,4]输出: [1,4,2,3] 输入: head = [1,2,3,4,5]输出: [1,5,2,4,3] 代码如下/** * Definition for singly-linked list. 这是关于链表结构的说明 * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */ class Solution &#123; public void reorderList(ListNode head) &#123; if(head.next==null||head.next.next==null) return ; ListNode fast=head; ListNode slow=head; //快慢指针 找到中点 //具体是快指针一次走两步 慢指针一次走一步 快指针走到头 慢指针走到链表中点 while(fast.next!=null&amp;&amp;fast.next.next!=null)&#123; fast=fast.next.next; slow=slow.next; &#125; ListNode newHead=slow.next; slow.next=null; newHead=reverse(newHead); while(newHead!=null)&#123; ListNode temp = newHead.next; newHead.next = head.next; head.next = newHead; head = newHead.next; newHead = temp; &#125; &#125; //反转链表 public ListNode reverse(ListNode head)&#123; ListNode pre=null; ListNode next=null; while(head!=null)&#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre; &#125; &#125; 写在后面​ 这个题目思路虽然不难想，但是实现有很多技巧，例如快慢指针、反转链表、合并链表这些小技巧，这都是阶梯模板。任重道远！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-4","slug":"刷题日记 day 4","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T11:07:28.694Z","comments":true,"path":"2021/09/24/刷题日记 day 4/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%204/","excerpt":"","text":"题目背景介绍今天写的是回溯算法解决的n皇后，在LeetCode上是第51题，难度是困难！ n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 首先来看一下皇后们的约束条件： 不能同行 不能同列 不能同斜线 唉，是个在二维数组上的回溯，这可咋整呢？ 代码实现class Solution &#123; List&lt;List&lt;String&gt;&gt; res=new ArrayList&lt;&gt;();//存放正确的结果集合 public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; char[][] chessboard=new char[n][n];//定义一个棋盘数组 //下面给棋盘数组赋值这个方式很轻巧，值得借鉴 for(char[] c:chessboard)&#123; Arrays.fill(c,&#39;.&#39;); &#125; backtracking(n,0,chessboard); return res; &#125; public void backtracking(int n,int row,char[][] chessboard)&#123; //函数参数row指的是棋盘的行数，也是递归树的深度 if(row==n)&#123; //当棋盘的行数等于n，就说明每一行都正确摆放了Q，可以加入正确的结果集合res res.add(new ArrayList&lt;&gt;(transform(chessboard))); return; &#125; for(int col=0;col&lt;n;++col)&#123; //这里的col指的是棋盘的列数，先判断当前棋盘的情况是不是满足要求 if(check(row,col,n,chessboard))&#123; chessboard[row][col]=&#39;Q&#39;;//处理棋盘 backtracking(n,row+1,chessboard); chessboard[row][col]=&#39;.&#39;;//回溯 撤销处理棋盘的操作 &#125; &#125; &#125; public List transform(char[][] chessboard)&#123; //这个函数是将字符二维数组转化为list List&lt;String&gt; path=new ArrayList&lt;&gt;(); for(char[] c:chessboard)&#123; path.add(String.copyValueOf(c)); &#125; return path; &#125; public boolean check(int row,int col,int n,char[][] chessboard)&#123; // 这个函数是检查棋盘的现状是否满足条件，主要从三个方面纵的方向不能有多个Q // 两个对角线上不能有多个Q for(int i=0;i&lt;n;i++)&#123; //检查列 if(chessboard[i][col]==&#39;Q&#39;) return false; &#125; for(int i=row-1,j=col-1;i&gt;=0&amp;&amp;j&gt;=0;i--,j--)&#123; //检查45度对角线 if(chessboard[i][j]==&#39;Q&#39;) return false; &#125; for(int i=row-1,j=col+1;i&gt;=0&amp;&amp;j&lt;=n-1;i--,j++)&#123; //检查135度对角线 if(chessboard[i][j]==&#39;Q&#39;) return false; &#125; return true; &#125; &#125; 分析与小结先来看看我画的递归树吧，这样讲的比较清晰。 可以看出来递归树的深度由棋盘的行数决定，每一层的情况由棋盘的列数决定。这也就是我们写题的着手方向。这个题比较需要注意的点在于这个图的建立，以及检查函数里对角线的排查，至于为啥不排查每一行的元素？这个你看图，每一行的Q都是独立的，所以不需要。这个不是我自己想出来的，是看别的大佬的题解。但弄懂以及把那个图画好也花了我不少时间。任重道远，仍需不断前行！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-5","slug":"刷题日记 day 5","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:14.981Z","comments":true,"path":"2021/09/24/刷题日记 day 5/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%205/","excerpt":"","text":"初探贪心算法​ 终于结束了回溯，老实说回溯是真的有点难，虽然有模板，但是很多问题的解决方式不尽相同。刷了也有20道题差不多，但是真正有印象的就几题。不过现在学到贪心了，我有点难受。它没有模板，就一个局部最优的算法思想。但是解决问题想到了这个思想，真的非常简单。想不到就呵呵了。 两个题目下面是我今天被贪心折磨的日常：LeetCode第53题 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums = [1]输出：1 示例 3： 输入：nums = [0]输出：0 示例 4： 输入：nums = [-1]输出：-1 示例 5： 输入：nums = [-100000]输出：-100000 提示： 1 &lt;= nums.length &lt;= 3 * 104-105 &lt;= nums[i] &lt;= 105 暴力解法 class Solution &#123; public int maxSubArray(int[] nums) &#123; int maxValue=Integer.MIN_VALUE; for(int i=0;i&lt;nums.length;i++)&#123; int count=0; for(int j=i;j&lt;nums.length;j++)&#123; count+=nums[j]; maxValue=count&gt;maxValue?count:maxValue; &#125; &#125; return maxValue; &#125; &#125; 时间复杂度是：O(n^2) 但是如果用贪心算法来写： class Solution &#123; public int maxSubArray(int[] nums) &#123; int maxValue=Integer.MIN_VALUE; int count=0; for(int i=0;i&lt;nums.length;i++)&#123; count+=nums[i]; if(count&gt;maxValue) maxValue=count; if(count&lt;0) count=0; &#125; return maxValue; &#125; &#125; 这个算法的时间复杂度很明显是O(n),初看还不是很明白，其实就是用了一个小技巧：我们都知道如果count后面加的是一个负数，就一定会让和变小，所以我们一旦碰到让count小于0的数据，就直接将count初始化为0，在从头开始记录count。这样看起来就使每一步都使得count是最大的，因为让count变成负数的元素我不会加入。这就是贪心的体现，但是这个很难想到呀！所以说贪心没有模板、只有一次次的踩坑积累经验，才可能想到有时候可以使用贪心。 LeetCode第55题 跳跃游戏给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。 示例 1： 输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。示例 2： 输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 提示： 1 &lt;= nums.length &lt;= 3 * 1040 &lt;= nums[i] &lt;= 105 这个题目就有点符合现实了，有点像跳台阶，其实可以从后往前跳，判断前一个节点是否能到达最后一个节点，如果可以就更新当前节点为最后一个节点。这是一种思路。但是贪心法更赖皮： class Solution &#123; public boolean canJump(int[] nums) &#123; int cover=0; if(nums.length==1) return true; for(int i=0;i&lt;=cover;i++)&#123; cover=Math.max(i+nums[i],cover); if(cover&gt;=nums.length-1) return true; &#125; return false; &#125; &#125; 看完也是不明所以，看了题解后感慨十分赖皮！其实就是看一个覆盖范围。你当前能走的步数的最大值是否覆盖到了最后一个元素，如果是肯定能走到。每次更新最大覆盖范围，这也是贪心法。 分析与小结做贪心的题目就感觉手上有本秘籍，很厉害。但是就是不会用，但是当你以为它就是废物时，丢掉了，别人捡起来，看了秘籍后成了你梦想成为的人。唉。任重而道远！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-7","slug":"刷题日记 day 7","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:24.428Z","comments":true,"path":"2021/09/24/刷题日记 day 7/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%207/","excerpt":"","text":"何为动态规划​ 动态规划就是Dynamic Programming，简称DP。如果解决一个问题需要解决它的很多重叠子问题，这个时候就需要用到动态规划。 ​ 动态规划的解题步骤： 确定dp数组以及下标的含义 确定递推公式 dp数组的初始化 确定遍历顺序 举例推导dp数组 题目背景今天写的第一题是我们的老熟题：509. 斐波那契数 。这个题目之前用的是递归，今天是动态规划。今天的第二题就有点难理解了：746. 使用最小花费爬楼梯。 代码如下 斐波那契数 class Solution &#123; public int fib(int n) &#123; if(n&lt;=1) return n; int[] dp=new int[n+1]; dp[0]=0; dp[1]=1; for(int i=2;i&lt;dp.length;i++)&#123; dp[i]=dp[i-1]+dp[i-2];//这个就是递推公式 &#125; return dp[n]; &#125; &#125; 使用最小花费爬楼梯 class Solution &#123; public int minCostClimbingStairs(int[] cost) &#123; int len=cost.length; int[] dp=new int[len]; dp[0]=cost[0]; dp[1]=cost[1]; for(int i=2;i&lt;len;i++)&#123; //递推关系式 dp[i]=Math.min(dp[i-1]+cost[i],dp[i-2]+cost[i]); &#125; return Math.min(dp[len-1],dp[len-2]); &#125; &#125; 分析与小结​ 从题解代码就可以很清楚的看出，dp数组的下标就表示第几个斐波那契数，而数组相对存储的就是第几个斐波那契数的值，递推公式题目也给了。所以解题十分方便。而第二题是斐波那契数列的变形，非常巧妙。我们每到达一个阶梯，都是从它的上一级或者上两级阶梯，所以当前花费最小将从它的上一级花费和上上一级花费之中诞生。这就是递推关系式： dp[i]=Math.min(dp[i-1]+cost[i],dp[i-2]+cost[i]);的由来。 ​ 今天的动态规划就到这里，持之以恒！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-6","slug":"刷题日记 day 6","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:19.641Z","comments":true,"path":"2021/09/24/刷题日记 day 6/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%206/","excerpt":"","text":"写在前面这两天被贪心折磨，贪心真的很难想到，初看题目有点看不懂，好不容易推演了两个测试，明白了题目的用意，但还是无从下手。一看题解代码和分析，就感觉自己是个傻zi。 今天写了两个贪心的题目，738. 单调递增的数字以及714. 买卖股票的最佳时机含手续费，这两题的代码都很简单，但都非常难想到。 代码如下 单调递增的数字 class Solution &#123; //解法一：暴力解法 很容易想到但是会超时 public int monotoneIncreasingDigits(int n) &#123; for(int i=n;i&gt;0;i--)&#123; if(check(i)) return i; &#125; return 0; &#125; public boolean check(int num)&#123; int max=10; while(num!=0)&#123; int t=num%10;//取出最后一位元素 if(t&lt;=max)&#123; max=t; &#125;else&#123; return false; &#125; num/=10; &#125; return true; &#125; &#125; class Solution &#123; /*解法二：从后往前遍历 n转化为字符数组a后 若a[i]&lt;a[i-1] 说明不是递增的 要进行调整 具体操作就是吧a[i-1]减一，以及把i以后的数字全部变成9，听起来很抽象。 如：n等于332 它的变化顺序是 332-&gt;329-&gt;299 这样经过两次调整就能得到正确结果，而且这 个算法时间复杂度是O(n). */ public int monotoneIncreasingDigits(int n) &#123; String s=String.valueOf(n);//转换成字符串更简单 int len=s.length(); int flag=len; char[] a=s.toCharArray(); for(int i=len-1;i&gt;=1;i--)&#123; if(a[i]&lt;a[i-1])&#123; flag=i; a[i-1]--; &#125; &#125; for(int i=flag;i&lt;len;i++)&#123; a[i]=&#39;9&#39;; &#125; return Integer.parseInt(new String(a)); &#125; &#125; 买卖股票的最佳时机含手续费 class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int minPay=prices[0]+fee; int sum=0; for(int i:prices)&#123; if(i+fee&lt;minPay) minPay=i+fee; else if(i&gt;minPay)&#123; sum+=i-minPay; minPay=i; &#125; &#125; return sum; &#125; &#125; 写在后面第二个题太难想到了，我也不想写啥分析，头晕。好在是终于结束了贪心(仓促)，明天动态规划！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-8","slug":"刷题日记 day 8","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:29.558Z","comments":true,"path":"2021/09/24/刷题日记 day 8/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%208/","excerpt":"","text":"初探01背包问题​ 记得我第一次遇到01背包还是上学期，在算法课上听过老师讲动态规划和回溯的时候，当时觉得这个问题理解起来这么简单，为啥这么重要？当我开始想着写出它的代码。呵呵，一个菜鸡怎么可能会写代码呢。今天终于刷到了01背包问题，发现这个问题的原型是很简单不错，但是它的变形就不是那么容易看穿了。 ​ 一切的动态规划最重要的就是找递推关系式，在这个问题中。我们的动规数组**dp[j]**，的含义是啥呢？它表示：容量为j的背包所能容纳的最大的物品价值。它的递推公式是： **dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]);**因为背包外的物品只有两个选择：放入背包或者不放入。所以背包的价值也就在这两个状态里产生，不放就是dp[j]，放进去了，就是之前背包的价值加上这个物品的价值。非常好理解！ ​ 然后我们就要思考一下dp数组的初始化问题，很明显dp[0]肯定是0，因为背包内没有物品，自然也就没有最大价值一说了。 ​ 再者就要考虑一下遍历顺序，我们必须倒序遍历数组。这是因为：为了保证物品i只会被放入一次！ 例如：物品0的重量为weight[0]=1,其价值value[0]=15， 那么将它放入背包容量为1的情况下：dp[1]=dp[1-weight[0]]+value[0]=15 将它放入背包容量为2的情况下：dp[2]=dp[2-weight[0]]+value[0]=30; 这时就会发现放入容量为2的背包的时候，最大价值应该是15，但是正序遍历的结果是30，这就是因为物品0被重复放入了。 反之我们先放入容量为2背包，在放入容量为1的背包就不会出现这样的问题。 ​ 下面有两个背包问题的实例，请仔细揣摩： 两个问题问题一：416. 分割等和子集 题目背景：给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 题目实例： 输入：nums = [1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。 输入：nums = [1,2,3,5] 输出：false 解释：数组不能分割成两个元素和相等的子集。 问题二：1049. 最后一块石头的重量 II 题目背景：有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎；如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。 题目实例： 输入：stones = [2,7,4,1,8,1]输出：1解释：组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。 解决代码问题一class Solution &#123; public boolean canPartition(int[] nums) &#123; int sum=0; //初始化dp数组的容量 int[] dp=new int[200*100+1]; for(int i=0;i&lt;nums.length;i++)&#123; sum+=nums[i]; &#125; //如果不能分成完全相等的两堆或者说两个子集 就return false if(sum%2==1) return false; //我们的目标是在背包里尝试装入最大价值为sum/2的物品 int target=sum/2; for(int i=0;i&lt;nums.length;i++)&#123; //注意这里是逆向遍历 for(int j=target;j&gt;=nums[i];j--)&#123; //递推公式 老套路了 dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i]); &#125; &#125; /*最后这个判断很灵性：如果背包容量为target时的最大价值也为target 就说明是可以分为最大子集为原数组集合的一半*/ if(dp[target]==target) return true; return false; &#125; &#125; 问题二class Solution &#123; public int lastStoneWeightII(int[] stones) &#123; int sum=0; int[] dp=new int[30*100/2+1]; for(int x:stones)&#123; sum+=x; &#125; int target=sum/2; for(int i=0;i&lt;stones.length;i++)&#123; for(int j=target;j&gt;=stones[i];j--)&#123; dp[j]=Math.max(dp[j],dp[j-stones[i]]+stones[i]); &#125; &#125; return (sum-dp[target])-dp[target]; &#125; &#125; 小结与分析​ 问题一的思路主要就是：将原数组划分成两个最大的子集，两个子集的和是相等的就return true。就可以理解为将原数组的元素放入一个背包，看看背包的最大值是否能达到原数组的一半。具体分析过程就在代码注释里面。 ​ 问题二？ 看看代码不就会了？(狗头) 哈哈哈","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-2","slug":"刷题日记day 2","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T10:25:23.584Z","comments":true,"path":"2021/09/24/刷题日记day 2/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0day%202/","excerpt":"","text":"写在前面好久没写博客了，虽然我的博客没人看，但是我觉得写博客是为了将自己的知识水平提高。写博客还可以让以后回顾知识变得更简单。之前一直没写主要是没啥兴趣，刷题在刚开始简直折磨，不夸张的说开始每一道题都是看答案的，有的看了答案也没弄懂，简直不知所云。对Java的集合类和数据结构也不是很熟悉，很多常用的方法函数不知道。经过20天左右的时间，我基本对刷题有一点的感觉了，开始越刷越快了。这个时候我想要慢下来，慢慢把刷的题总结一下。这就是再次写博客的理由。 题目概述及解法今天刷的还是回溯算法系列，这一题是：LeetCode第131题—分割回文串 题目的意思是：给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。 回文串 是正着读和反着读都一样的字符串。 示例 1： 输入：s = “aab”输出：[[“a”,”a”,”b”],[“aa”,”b”]]示例 2： 输入：s = “a”输出：[[“a”]] 提示： 1 &lt;= s.length &lt;= 16s 仅由小写英文字母组成 解法代码：class Solution &#123; List&lt;List&lt;String&gt;&gt; res= new ArrayList&lt;&gt;();//存放正确结果的集合 Deque&lt;String&gt; path=new LinkedList&lt;&gt;();//存放单个正确结果(这里选择双端队列，若选择list删除时会出现错误) public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; backtracking(s,0); return res; &#125; public void backtracking(String s,int index)&#123;//回溯函数(也是递归函数) //确定回溯的终止条件(本题是： 当截取字符串的位置到达字符串最后一位就说明此次获取完成) if(index&gt;=s.length())&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; //for循环是解空间树的横向遍历，而回溯函数是解空间树的纵向遍历 for(int i=index;i&lt;s.length();i++)&#123; //先判断是否是回文串，是就截取放入path中，不是就跳过这次循环 if(isHuiWen(s,index,i))&#123; String str=s.substring(index,i+1); path.addLast(str); &#125;else&#123; continue; &#125; backtracking(s,i+1);//回溯函数(i+1是为了不再重复的截取) path.removeLast();//回溯 撤销之前处理节点的过程 &#125; &#125; //下面这个函数是判断是否是回文串 public boolean isHuiWen(String s,int index,int end)&#123; for(int i=index,j=end;i&lt;j;i++,j--)&#123; if(s.charAt(i)!=s.charAt(j)) return false; &#125; return true; &#125; &#125; 解法我在代码上做了详细的注释说明，主要就是截取字符串和数据结构Deque的选择。 写在后面虽然每天写的题不只一题，但是要是全部都记录下来，有点费时间，还是每天找一个喜欢的记录，这样也挺好的。 ​ 加油","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-3","slug":"刷题日记 day 9","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:35.658Z","comments":true,"path":"2021/09/24/刷题日记 day 9/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%209/","excerpt":"","text":"初识完全背包​ 完全背包是背包问题的变形之一，老实说01背包我也才半知半解，今天看题解也还是雾中看花。完全背包就是背包只有一个，但是物品可以重复放入无数次。即每种物品有无数件。 ​ 首先我们列出01背包的核心代码： for(int i=0;i&lt;weight.length;i++)&#123;//遍历物品 for(int j=bagWeight;j&gt;=weight[i];j--)&#123;//遍历背包容量 dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]); &#125; &#125; 01背包内嵌的for循环是从大到小遍历，为了保证每个物品仅被添加一次。 而完全背包的物品可以添加多次，所以内层循环是要从小到大： for(int i=0;i&lt;weight.length;i++)&#123;//遍历物品 for(int j=weight[i];j&lt;bagWeight;j++)&#123;//遍历背包容量 dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]); &#125; &#125; 两个小题第一题：518. 零钱兑换 II给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。 假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数 实例： 输入：amount = 5, coins = [1, 2, 5]输出：4解释：有四种方式可以凑成总金额：5=55=2+2+15=2+1+1+15=1+1+1+1+1 第二题：377. 组合总和 Ⅳ给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。 题目数据保证答案符合 32 位整数范围。 实例： 输入：nums = [1,2,3], target = 4输出：7解释：所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合 代码详解第一题class Solution &#123; public int change(int amount, int[] coins) &#123; int[] dp=new int[amount+1]; dp[0]=1; for(int i=0;i&lt;coins.length;i++)&#123;//遍历物品 for(int j=coins[i];j&lt;=amount;j++)&#123;//遍历背包 dp[j]+=dp[j-coins[i]]; &#125; &#125; return dp[amount]; &#125; &#125; 第二题class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; int[] dp=new int[target+1]; dp[0]=1; for(int i=0;i&lt;=target;i++)&#123;//遍历背包 for(int j=0;j&lt;nums.length;j++)&#123;//遍历物品 if(i-nums[j]&gt;=0)&#123; dp[i]+=dp[i-nums[j]]; &#125; &#125; &#125; return dp[target]; &#125; &#125; 分析与小结这个完全背包，这里有两种类型：组合和排列。 从代码可以看出来：组合问题for循环是先遍历物品，再遍历背包，而排列问题for循环先遍历背包，再遍历物品。 全是套路呀！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"刷题日记 day-3","slug":"刷题日记day 3","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:29:05.131Z","comments":true,"path":"2021/09/24/刷题日记day 3/","link":"","permalink":"http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0day%203/","excerpt":"","text":"题目概述LeetCode第46题：全排列 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1： 输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]示例 2： 输入：nums = [0,1]输出：[[0,1],[1,0]]示例 3： 输入：nums = [1]输出：[[1]] 提示： 1 &lt;= nums.length &lt;= 6-10 &lt;= nums[i] &lt;= 10nums 中的所有整数 互不相同 解决代码class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();//存放正确结果的集合 List&lt;Integer&gt; path=new ArrayList&lt;&gt;();//存放单个正确的结果 public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; boolean[] used=new boolean[nums.length];//需要一个数组来判断集合的元素是否重复使用 backtracking(nums,used); return res; &#125; //子集问题和排列问题最大的不同，就是函数参数不再需要index，而是换成了boolean数组 public void backtracking(int[] nums,boolean[] used)&#123; //当path存放的元素到了全排列的数组的大小就可以停止，并传入res中 if(path.size()==nums.length)&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for(int i=0;i&lt;nums.length;i++)&#123; //used数组就是记录path里面哪些元素已经被使用了，一个排列里元素只能使用一次 if(used[i]==true) continue; used[i]=true; path.add(nums[i]); backtracking(nums,used); path.remove(path.size()-1); used[i]=false; &#125; &#125; &#125; 分析小结这个题目是回溯算法的另一个擅长的拿手好戏，全排列和子集、组合问题的最大不同就是不需要传起始地址，因为每一层的元素可以重复使用，但是在一个分支里每个元素都只能用一次。下面是我画的一张解空间树的图，可以加深理解。 同时也想说，第一次使用画图工具，好难用，但是不用这个肯定画的又丑又难看懂。还是要继续努力，学习新知识！！！","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"}],"tags":[{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"}],"author":"zsk"},{"title":"标签测试","slug":"标签测试","date":"2021-09-23T16:00:00.000Z","updated":"2021-09-24T08:27:10.600Z","comments":true,"path":"2021/09/24/标签测试/","link":"","permalink":"http://example.com/2021/09/24/%E6%A0%87%E7%AD%BE%E6%B5%8B%E8%AF%95/","excerpt":"","text":"text带 下划线 的文本；带 着重号 的文本；带 波浪线 的文本；带 删除线 的文本 键盘样式的文本：⌘ + D 密码样式的文本：这里没有验证码 note这里可以是一段有用的希望能引人注意的信息 checkbox 纯文本测试 radio 纯文本测试 timeline2021-09-23 timeline测试 2021-09-22 1、 2021-09-21 2、 2021-09-23 3、 folding 这是一个折叠框 其他的还有好多元素实在太丰富了，我写个博客还用得着这么多？太看得起我了也hhh","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}],"author":"zsk"},{"title":"test","slug":"front-matter的测试","date":"2021-09-22T16:00:00.000Z","updated":"2023-02-25T04:09:11.178Z","comments":true,"path":"2021/09/23/front-matter的测试/","link":"","permalink":"http://example.com/2021/09/23/front-matter%E7%9A%84%E6%B5%8B%E8%AF%95/","excerpt":"","text":"this is a test!","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}],"author":"zsk"},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2021-09-22T10:51:47.372Z","updated":"2021-09-22T10:53:03.523Z","comments":true,"path":"2021/09/22/我的第一篇博客文章/","link":"","permalink":"http://example.com/2021/09/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"第一个标题第二个标题","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-09-22T10:34:25.959Z","updated":"2021-09-22T10:34:25.959Z","comments":true,"path":"2021/09/22/hello-world/","link":"","permalink":"http://example.com/2021/09/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"考研","slug":"考研","permalink":"http://example.com/categories/%E8%80%83%E7%A0%94/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"考研复习","slug":"考研复习","permalink":"http://example.com/tags/%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/"},{"name":"刷题心得","slug":"刷题心得","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]}
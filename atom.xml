<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zsk&#39;s personal blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-09-24T09:00:34.973Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>刷题日记 day-1</title>
    <link href="http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20Day01/"/>
    <id>http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20Day01/</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2021-09-24T09:00:34.973Z</updated>
    
    <content type="html"><![CDATA[<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><h4 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h4><p>仔细一看这就是二分查找的应用典型呀，虽然我知道要用二分查找，但是在做的时候还是没有一个明确的思路，搞了一晚上还是没能攻破，诶，看了题解以后就感觉好简单。分析一下我下面写的代码，防止以后再看的时候就看不懂了。</p><ol><li><p>这个Solution包括三个函数，第一个就是主函数，第二个和第三个如名字一样，分别是寻找target在数组的第一个位置和最后一次出现的位置，二分查找的最重要的代码体就是：</p><pre><code class="java">int left=0;int right=nums.length-1;while(left&lt;=right)&#123;    int mid=left+(right-left)/2;    if(nums[mid]&gt;target)        right=mid-1;    if(nums[mid]&lt;target)        left=mid+1;&#125;return left;</code></pre></li></ol><ol start="2"><li> <em><strong>注释1</strong></em>这个地方为啥多此一举 (right=mid-1;) ？这个是为了找到第一个出现target位置的操作，注释2这个地方加一个判断就是要搞清楚在数组里找没找到target，这两个地方都是针对这个题目做出的改变。</li></ol><ol start="3"><li>整体来说，就是利用二分查找在数组里找了两次target，分别找到第一个和最后一个出现target的位置。</li></ol><h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><pre><code class="java">class Solution &#123;    public int[] searchRange(int[] nums, int target) &#123;        int firstPosition=searchFirstPosition(nums,target);        if(nums.length==0||firstPosition==-1)        return new int[]&#123;-1,-1&#125;;        int lastPosition=searchLastPosition(nums,target);        return new int[]&#123;firstPosition,lastPosition&#125;;        &#125;    public int searchFirstPosition(int[] nums,int target)&#123;        int left=0;        int right=nums.length-1;        while(left&lt;=right)        &#123;            int mid=left+(right-left)/2;            if(nums[mid]==target)//注释1                right=mid-1;            else if(nums[mid]&lt;target)                left=mid+1;            else right=mid-1;        &#125;        if(left!=nums.length&amp;&amp;nums[left]==target)//注释2            return left;        else            return -1;    &#125;    public int searchLastPosition(int[] nums,int target)&#123;        int left=0;        int right=nums.length-1;        while(left&lt;=right)        &#123;            int mid=left+(right-left)/2;            if(nums[mid]==target)                left=mid+1;            else if(nums[mid]&lt;target)                left=mid+1;            else right=mid-1;        &#125;        return right;    &#125;&#125;</code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>二分查找很有精神！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;34-在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;a href=&quot;#34-在排序数组中查找元素的第一个和最后一个位置&quot; class=&quot;headerlink&quot; title=&quot;34. 在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="刷题心得" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 day-4</title>
    <link href="http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%204/"/>
    <id>http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%204/</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2021-09-24T11:07:28.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目背景介绍"><a href="#题目背景介绍" class="headerlink" title="题目背景介绍"></a>题目背景介绍</h2><p>今天写的是回溯算法解决的n皇后，在LeetCode上是第51题，难度是困难！</p><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p><img src="https://pic.imgdb.cn/item/614db15d2ab3f51d911b7a94.png" class="lazyload" data-srcset="https://pic.imgdb.cn/item/614db15d2ab3f51d911b7a94.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>首先来看一下皇后们的约束条件：</p><ol><li><strong>不能同行</strong></li><li><strong>不能同列</strong></li><li><strong>不能同斜线</strong></li></ol><p><em><strong>唉，是个在二维数组上的回溯，这可咋整呢？</strong></em></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">class Solution &#123;    List&lt;List&lt;String&gt;&gt; res=new ArrayList&lt;&gt;();//存放正确的结果集合    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;        char[][] chessboard=new char[n][n];//定义一个棋盘数组        //下面给棋盘数组赋值这个方式很轻巧，值得借鉴        for(char[] c:chessboard)&#123;            Arrays.fill(c,&#39;.&#39;);        &#125;        backtracking(n,0,chessboard);        return res;    &#125;    public void backtracking(int n,int row,char[][] chessboard)&#123;        //函数参数row指的是棋盘的行数，也是递归树的深度        if(row==n)&#123;            //当棋盘的行数等于n，就说明每一行都正确摆放了Q，可以加入正确的结果集合res            res.add(new ArrayList&lt;&gt;(transform(chessboard)));            return;        &#125;        for(int col=0;col&lt;n;++col)&#123;            //这里的col指的是棋盘的列数，先判断当前棋盘的情况是不是满足要求            if(check(row,col,n,chessboard))&#123;                chessboard[row][col]=&#39;Q&#39;;//处理棋盘                backtracking(n,row+1,chessboard);                chessboard[row][col]=&#39;.&#39;;//回溯 撤销处理棋盘的操作            &#125;        &#125;    &#125;    public List transform(char[][] chessboard)&#123;        //这个函数是将字符二维数组转化为list        List&lt;String&gt; path=new ArrayList&lt;&gt;();        for(char[] c:chessboard)&#123;            path.add(String.copyValueOf(c));        &#125;        return path;    &#125;    public boolean check(int row,int col,int n,char[][] chessboard)&#123;         // 这个函数是检查棋盘的现状是否满足条件，主要从三个方面纵的方向不能有多个Q         // 两个对角线上不能有多个Q                for(int i=0;i&lt;n;i++)&#123;            //检查列            if(chessboard[i][col]==&#39;Q&#39;)                return false;        &#125;                for(int i=row-1,j=col-1;i&gt;=0&amp;&amp;j&gt;=0;i--,j--)&#123;            //检查45度对角线            if(chessboard[i][j]==&#39;Q&#39;)                return false;        &#125;               for(int i=row-1,j=col+1;i&gt;=0&amp;&amp;j&lt;=n-1;i--,j++)&#123;             //检查135度对角线            if(chessboard[i][j]==&#39;Q&#39;)                return false;        &#125;        return true;    &#125;&#125;</code></pre><h2 id="分析与小结"><a href="#分析与小结" class="headerlink" title="分析与小结"></a>分析与小结</h2><p>先来看看我画的递归树吧，这样讲的比较清晰。</p><p><img src="https://pic.imgdb.cn/item/614d881a2ab3f51d91e55336.png" class="lazyload" data-srcset="https://pic.imgdb.cn/item/614d881a2ab3f51d91e55336.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>可以看出来递归树的深度由棋盘的行数决定，每一层的情况由棋盘的列数决定。这也就是我们写题的着手方向。这个题比较需要注意的点在于这个图的建立，以及检查函数里对角线的排查，至于为啥不排查每一行的元素？这个你看图，每一行的Q都是独立的，所以不需要。这个不是我自己想出来的，是看别的大佬的题解。但弄懂以及把那个图画好也花了我不少时间。任重道远，仍需不断前行！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目背景介绍&quot;&gt;&lt;a href=&quot;#题目背景介绍&quot; class=&quot;headerlink&quot; title=&quot;题目背景介绍&quot;&gt;&lt;/a&gt;题目背景介绍&lt;/h2&gt;&lt;p&gt;今天写的是回溯算法解决的n皇后，在LeetCode上是第51题，难度是困难！&lt;/p&gt;
&lt;p&gt;n 皇后问题 研</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="刷题心得" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 day-10</title>
    <link href="http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%2010/"/>
    <id>http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%2010/</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2021-09-24T08:28:49.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>​        李奶奶的动态规划！！！真的觉得自己智商过低，不适合刷动态规划。于是我找了一个稍微简单一点的链表问题，题目来自于：**LeetCode <a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a>**，这个题目的解法思路很多，我也想出来几种。但由于我对链表结构的不够熟悉，不能完美的利用链表结构特点，只能理解别人写的题解。题解的思路也很好理解：</p><ol><li>找到链表的中点分割链表</li><li>将分割后的后半部分进行链表反转</li><li>将翻转后的链表和前半部分进行合并</li></ol><p>题目的背景如下： 给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p><p> L0 → L1 → … → Ln-1 → Ln<br>请将其重新排列后变为：</p><p>L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …</p><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>实例：</p><blockquote><p>输入: head = [1,2,3,4]<br>输出: [1,4,2,3]</p></blockquote><blockquote><p>输入: head = [1,2,3,4,5]<br>输出: [1,5,2,4,3]</p></blockquote><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><pre><code class="java">/** * Definition for singly-linked list.         这是关于链表结构的说明 * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public void reorderList(ListNode head) &#123;        if(head.next==null||head.next.next==null)            return ;        ListNode fast=head;        ListNode slow=head;        //快慢指针 找到中点        //具体是快指针一次走两步 慢指针一次走一步 快指针走到头 慢指针走到链表中点        while(fast.next!=null&amp;&amp;fast.next.next!=null)&#123;            fast=fast.next.next;            slow=slow.next;        &#125;        ListNode newHead=slow.next;        slow.next=null;        newHead=reverse(newHead);        while(newHead!=null)&#123;            ListNode temp = newHead.next;            newHead.next = head.next;            head.next = newHead;            head = newHead.next;            newHead = temp;        &#125;    &#125;    //反转链表    public ListNode reverse(ListNode head)&#123;        ListNode pre=null;        ListNode next=null;        while(head!=null)&#123;            next = head.next;            head.next = pre;            pre = head;            head = next;        &#125;        return pre;    &#125;&#125;</code></pre><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>​        这个题目思路虽然不难想，但是实现有很多技巧，例如快慢指针、反转链表、合并链表这些小技巧，这都是阶梯模板。任重道远！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;​        李奶奶的动态规划！！！真的觉得自己智商过低，不适合刷动态规划。于是我找了一个稍微简单一点的链表问题，题目来</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="刷题心得" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 day-5</title>
    <link href="http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%205/"/>
    <id>http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%205/</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2021-09-24T08:29:14.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初探贪心算法"><a href="#初探贪心算法" class="headerlink" title="初探贪心算法"></a>初探贪心算法</h2><p>​        终于结束了回溯，老实说回溯是真的有点难，虽然有模板，但是很多问题的解决方式不尽相同。刷了也有20道题差不多，但是真正有印象的就几题。不过现在学到贪心了，我有点难受。它没有模板，就一个局部最优的算法思想。但是解决问题想到了这个思想，真的非常简单。想不到就呵呵了。</p><h2 id="两个题目"><a href="#两个题目" class="headerlink" title="两个题目"></a>两个题目</h2><h3 id="下面是我今天被贪心折磨的日常："><a href="#下面是我今天被贪心折磨的日常：" class="headerlink" title="下面是我今天被贪心折磨的日常："></a>下面是我今天被贪心折磨的日常：</h3><h4 id="LeetCode第53题-最大子序和"><a href="#LeetCode第53题-最大子序和" class="headerlink" title="LeetCode第53题 最大子序和"></a>LeetCode第53题 <em><strong>最大子序和</strong></em></h4><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例 1：</p><p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p><p>示例 2：</p><p>输入：nums = [1]<br>输出：1</p><p>示例 3：</p><p>输入：nums = [0]<br>输出：0</p><p>示例 4：</p><p>输入：nums = [-1]<br>输出：-1</p><p>示例 5：</p><p>输入：nums = [-100000]<br>输出：-100000</p><p>提示：</p><p>1 &lt;= nums.length &lt;= 3 * 104<br>-105 &lt;= nums[i] &lt;= 105</p><p>暴力解法</p><pre><code class="java">class Solution &#123;    public int maxSubArray(int[] nums) &#123;        int maxValue=Integer.MIN_VALUE;                for(int i=0;i&lt;nums.length;i++)&#123;            int count=0;            for(int j=i;j&lt;nums.length;j++)&#123;                count+=nums[j];                maxValue=count&gt;maxValue?count:maxValue;            &#125;        &#125;        return maxValue;    &#125;&#125;</code></pre><p>时间复杂度是：O(n^2)</p><p>但是如果用贪心算法来写：</p><pre><code class="java">class Solution &#123;    public int maxSubArray(int[] nums) &#123;         int maxValue=Integer.MIN_VALUE;        int count=0;        for(int i=0;i&lt;nums.length;i++)&#123;            count+=nums[i];            if(count&gt;maxValue)                maxValue=count;            if(count&lt;0)                count=0;        &#125;        return maxValue;    &#125;&#125;</code></pre><p>这个算法的时间复杂度很明显是O(n),初看还不是很明白，其实就是用了一个小技巧：我们都知道如果count后面加的是一个负数，就一定会让和变小，所以我们一旦碰到让count小于0的数据，就直接将count初始化为0，在从头开始记录count。这样看起来就使每一步都使得count是最大的，因为让count变成负数的元素我不会加入。这就是贪心的体现，但是这个很难想到呀！所以说贪心没有模板、只有一次次的踩坑积累经验，才可能想到有时候可以使用贪心。</p><h4 id="LeetCode第55题-跳跃游戏"><a href="#LeetCode第55题-跳跃游戏" class="headerlink" title="LeetCode第55题 跳跃游戏"></a>LeetCode第55题 <em><strong>跳跃游戏</strong></em></h4><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。</p><p>示例 1：</p><p>输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。<br>示例 2：</p><p>输入：nums = [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</p><p>提示：</p><p>1 &lt;= nums.length &lt;= 3 * 104<br>0 &lt;= nums[i] &lt;= 105</p><p>这个题目就有点符合现实了，有点像跳台阶，其实可以从后往前跳，判断前一个节点是否能到达最后一个节点，如果可以就更新当前节点为最后一个节点。这是一种思路。但是贪心法更赖皮：</p><pre><code class="java">class Solution &#123;    public boolean canJump(int[] nums) &#123;        int cover=0;        if(nums.length==1)            return true;        for(int i=0;i&lt;=cover;i++)&#123;            cover=Math.max(i+nums[i],cover);            if(cover&gt;=nums.length-1)                return true;        &#125;        return false;    &#125;&#125;</code></pre><p>看完也是不明所以，看了题解后感慨十分赖皮！其实就是看一个覆盖范围。你当前能走的步数的最大值是否覆盖到了最后一个元素，如果是肯定能走到。每次更新最大覆盖范围，这也是贪心法。</p><h2 id="分析与小结"><a href="#分析与小结" class="headerlink" title="分析与小结"></a>分析与小结</h2><p>做贪心的题目就感觉手上有本秘籍，很厉害。但是就是不会用，但是当你以为它就是废物时，丢掉了，别人捡起来，看了秘籍后成了你梦想成为的人。唉。任重而道远！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初探贪心算法&quot;&gt;&lt;a href=&quot;#初探贪心算法&quot; class=&quot;headerlink&quot; title=&quot;初探贪心算法&quot;&gt;&lt;/a&gt;初探贪心算法&lt;/h2&gt;&lt;p&gt;​        终于结束了回溯，老实说回溯是真的有点难，虽然有模板，但是很多问题的解决方式不尽相同。刷了也</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="刷题心得" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 day-6</title>
    <link href="http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%206/"/>
    <id>http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%206/</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2021-09-24T08:29:19.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这两天被贪心折磨，贪心真的很难想到，初看题目有点看不懂，好不容易推演了两个测试，明白了题目的用意，但还是无从下手。一看题解代码和分析，就感觉自己是个傻zi。</p><blockquote><p>今天写了两个贪心的题目，<a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">738. 单调递增的数字</a>以及<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a>，这两题的代码都很简单，但都非常难想到。</p></blockquote><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><ol start="738"><li>单调递增的数字</li></ol><pre><code class="java">class Solution &#123;    //解法一：暴力解法 很容易想到但是会超时    public int monotoneIncreasingDigits(int n) &#123;        for(int i=n;i&gt;0;i--)&#123;            if(check(i))                return i;        &#125;        return 0;    &#125;    public boolean check(int num)&#123;        int max=10;        while(num!=0)&#123;            int t=num%10;//取出最后一位元素            if(t&lt;=max)&#123;                max=t;            &#125;else&#123;                return false;            &#125;            num/=10;        &#125;        return true;    &#125;&#125;</code></pre><pre><code class="java">class Solution &#123;    /*解法二：从后往前遍历 n转化为字符数组a后 若a[i]&lt;a[i-1] 说明不是递增的 要进行调整    具体操作就是吧a[i-1]减一，以及把i以后的数字全部变成9，听起来很抽象。    如：n等于332 它的变化顺序是 332-&gt;329-&gt;299 这样经过两次调整就能得到正确结果，而且这    个算法时间复杂度是O(n).    */    public int monotoneIncreasingDigits(int n) &#123;        String s=String.valueOf(n);//转换成字符串更简单        int len=s.length();        int flag=len;        char[] a=s.toCharArray();        for(int i=len-1;i&gt;=1;i--)&#123;            if(a[i]&lt;a[i-1])&#123;                flag=i;                a[i-1]--;            &#125;        &#125;        for(int i=flag;i&lt;len;i++)&#123;            a[i]=&#39;9&#39;;        &#125;        return Integer.parseInt(new String(a));    &#125;&#125;</code></pre><ol start="714"><li><em><strong>买卖股票的最佳时机含手续费</strong></em></li></ol><pre><code class="java">class Solution &#123;    public int maxProfit(int[] prices, int fee) &#123;        int minPay=prices[0]+fee;        int sum=0;        for(int i:prices)&#123;            if(i+fee&lt;minPay)                minPay=i+fee;            else if(i&gt;minPay)&#123;                sum+=i-minPay;                minPay=i;            &#125;        &#125;        return sum;    &#125;&#125;</code></pre><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>第二个题太难想到了，我也不想写啥分析，头晕。好在是终于结束了贪心(仓促)，明天动态规划！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;这两天被贪心折磨，贪心真的很难想到，初看题目有点看不懂，好不容易推演了两个测试，明白了题目的用意，但还是无从下手。一看题解代</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="刷题心得" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 day-7</title>
    <link href="http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%207/"/>
    <id>http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%207/</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2021-09-24T08:29:24.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何为动态规划"><a href="#何为动态规划" class="headerlink" title="何为动态规划"></a>何为动态规划</h2><p>​        动态规划就是Dynamic Programming，简称DP。如果解决一个问题需要解决它的很多重叠子问题，这个时候就需要用到动态规划。</p><p>​        动态规划的解题步骤：</p><ol><li>确定dp数组以及下标的含义</li><li>确定递推公式</li><li>dp数组的初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>今天写的第一题是我们的老熟题：<a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a> 。这个题目之前用的是递归，今天是动态规划。今天的第二题就有点难理解了：<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a>。</p><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><ol start="509"><li><em><strong>斐波那契数</strong></em></li></ol><pre><code class="java">class Solution &#123;    public int fib(int n) &#123;        if(n&lt;=1)            return n;        int[] dp=new int[n+1];        dp[0]=0;        dp[1]=1;        for(int i=2;i&lt;dp.length;i++)&#123;            dp[i]=dp[i-1]+dp[i-2];//这个就是递推公式        &#125;        return dp[n];    &#125;&#125;</code></pre><ol start="746"><li><em><strong>使用最小花费爬楼梯</strong></em></li></ol><pre><code class="java">class Solution &#123;    public int minCostClimbingStairs(int[] cost) &#123;        int len=cost.length;        int[] dp=new int[len];        dp[0]=cost[0];        dp[1]=cost[1];        for(int i=2;i&lt;len;i++)&#123;            //递推关系式            dp[i]=Math.min(dp[i-1]+cost[i],dp[i-2]+cost[i]);        &#125;        return Math.min(dp[len-1],dp[len-2]);    &#125;&#125;</code></pre><h2 id="分析与小结"><a href="#分析与小结" class="headerlink" title="分析与小结"></a>分析与小结</h2><p>​        从题解代码就可以很清楚的看出，dp数组的下标就表示第几个斐波那契数，而数组相对存储的就是第几个斐波那契数的值，递推公式题目也给了。所以解题十分方便。而第二题是斐波那契数列的变形，非常巧妙。我们每到达一个阶梯，都是从它的上一级或者上两级阶梯，所以当前花费最小将从它的上一级花费和上上一级花费之中诞生。这就是递推关系式： dp[i]=Math.min(dp[i-1]+cost[i],dp[i-2]+cost[i]);的由来。</p><p>​        今天的动态规划就到这里，持之以恒！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;何为动态规划&quot;&gt;&lt;a href=&quot;#何为动态规划&quot; class=&quot;headerlink&quot; title=&quot;何为动态规划&quot;&gt;&lt;/a&gt;何为动态规划&lt;/h2&gt;&lt;p&gt;​        动态规划就是Dynamic Programming，简称DP。如果解决一个问题需要解决它的</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="刷题心得" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 day-8</title>
    <link href="http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%208/"/>
    <id>http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%208/</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2021-09-24T08:29:29.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初探01背包问题"><a href="#初探01背包问题" class="headerlink" title="初探01背包问题"></a>初探01背包问题</h2><p>​        记得我第一次遇到01背包还是上学期，在算法课上听过老师讲动态规划和回溯的时候，当时觉得这个问题理解起来这么简单，为啥这么重要？当我开始想着写出它的代码。呵呵，一个菜鸡怎么可能会写代码呢。今天终于刷到了01背包问题，发现这个问题的原型是很简单不错，但是它的变形就不是那么容易看穿了。</p><p>​        一切的动态规划最重要的就是找递推关系式，在这个问题中。我们的动规数组**dp[j]**，的含义是啥呢？它表示：容量为j的背包所能容纳的最大的物品价值。它的递推公式是：       **dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]);**因为背包外的物品只有两个选择：放入背包或者不放入。所以背包的价值也就在这两个状态里产生，不放就是dp[j]，放进去了，就是之前背包的价值加上这个物品的价值。非常好理解！</p><p>​        然后我们就要思考一下dp数组的初始化问题，很明显dp[0]肯定是0，因为背包内没有物品，自然也就没有最大价值一说了。</p><p>​        再者就要考虑一下遍历顺序，我们必须<strong>倒序遍历数组</strong>。这是因为：<strong>为了保证物品i只会被放入一次！</strong></p><blockquote><p>例如：物品0的重量为weight[0]=1,其价值value[0]=15，</p></blockquote><p>那么将它放入背包容量为1的情况下：dp[1]=dp[1-weight[0]]+value[0]=15</p><p>将它放入背包容量为2的情况下：dp[2]=dp[2-weight[0]]+value[0]=30;</p><p>这时就会发现放入容量为2的背包的时候，最大价值应该是15，但是正序遍历的结果是30，这就是因为物品0被重复放入了。</p><p>反之我们先放入容量为2背包，在放入容量为1的背包就不会出现这样的问题。</p><p>​        下面有两个背包问题的实例，请仔细揣摩：</p><h2 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h2><h3 id="问题一：416-分割等和子集"><a href="#问题一：416-分割等和子集" class="headerlink" title="问题一：416. 分割等和子集"></a>问题一：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h3><ul><li><p>题目背景：给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p></li><li><p>题目实例：</p><blockquote><pre><code>输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。</code></pre></blockquote><blockquote><pre><code>输入：nums = [1,2,3,5]输出：false解释：数组不能分割成两个元素和相等的子集。</code></pre></blockquote></li></ul><h3 id="问题二：1049-最后一块石头的重量-II"><a href="#问题二：1049-最后一块石头的重量-II" class="headerlink" title="问题二：1049. 最后一块石头的重量 II"></a>问题二：<a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></h3><ul><li><p>题目背景：有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p><p>如果 x == y，那么两块石头都会被完全粉碎；<br>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。</p></li><li><p>题目实例：</p><blockquote><p>输入：stones = [2,7,4,1,8,1]<br>输出：1<br>解释：<br>组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，<br>组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，<br>组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，<br>组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p></blockquote></li></ul><h2 id="解决代码"><a href="#解决代码" class="headerlink" title="解决代码"></a>解决代码</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><pre><code class="java">class Solution &#123;    public boolean canPartition(int[] nums) &#123;        int sum=0;        //初始化dp数组的容量        int[] dp=new int[200*100+1];        for(int i=0;i&lt;nums.length;i++)&#123;            sum+=nums[i];        &#125;        //如果不能分成完全相等的两堆或者说两个子集 就return false        if(sum%2==1)             return false;        //我们的目标是在背包里尝试装入最大价值为sum/2的物品        int target=sum/2;        for(int i=0;i&lt;nums.length;i++)&#123;            //注意这里是逆向遍历            for(int j=target;j&gt;=nums[i];j--)&#123;                //递推公式 老套路了                dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i]);            &#125;        &#125;        /*最后这个判断很灵性：如果背包容量为target时的最大价值也为target        就说明是可以分为最大子集为原数组集合的一半*/        if(dp[target]==target)            return true;        return false;    &#125;&#125;</code></pre><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><pre><code class="java">class Solution &#123;    public int lastStoneWeightII(int[] stones) &#123;        int sum=0;        int[] dp=new int[30*100/2+1];        for(int x:stones)&#123;            sum+=x;        &#125;        int target=sum/2;        for(int i=0;i&lt;stones.length;i++)&#123;            for(int j=target;j&gt;=stones[i];j--)&#123;                dp[j]=Math.max(dp[j],dp[j-stones[i]]+stones[i]);            &#125;        &#125;        return (sum-dp[target])-dp[target];    &#125;&#125;</code></pre><h2 id="小结与分析"><a href="#小结与分析" class="headerlink" title="小结与分析"></a>小结与分析</h2><p>​        问题一的思路主要就是：将原数组划分成两个最大的子集，两个子集的和是相等的就return true。就可以理解为将原数组的元素放入一个背包，看看背包的最大值是否能达到原数组的一半。具体分析过程就在代码注释里面。</p><p>​        问题二？ 看看代码不就会了？(狗头) 哈哈哈</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初探01背包问题&quot;&gt;&lt;a href=&quot;#初探01背包问题&quot; class=&quot;headerlink&quot; title=&quot;初探01背包问题&quot;&gt;&lt;/a&gt;初探01背包问题&lt;/h2&gt;&lt;p&gt;​        记得我第一次遇到01背包还是上学期，在算法课上听过老师讲动态规划和回溯的时</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="刷题心得" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 day-3</title>
    <link href="http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%209/"/>
    <id>http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%20day%209/</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2021-09-24T08:29:35.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识完全背包"><a href="#初识完全背包" class="headerlink" title="初识完全背包"></a>初识完全背包</h2><p>​        完全背包是背包问题的变形之一，老实说01背包我也才半知半解，今天看题解也还是雾中看花。完全背包就是背包只有一个，但是物品可以重复放入无数次。即每种物品有无数件。</p><p>​        首先我们列出01背包的核心代码：</p><pre><code class="java">for(int i=0;i&lt;weight.length;i++)&#123;//遍历物品    for(int j=bagWeight;j&gt;=weight[i];j--)&#123;//遍历背包容量        dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]);    &#125;&#125;</code></pre><p><em>01背包内嵌的for循环是从大到小遍历，为了保证每个物品仅被添加一次。</em></p><p>而完全背包的物品可以添加多次，所以内层循环是要从小到大：</p><pre><code class="java">for(int i=0;i&lt;weight.length;i++)&#123;//遍历物品    for(int j=weight[i];j&lt;bagWeight;j++)&#123;//遍历背包容量        dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]);    &#125;&#125;</code></pre><h2 id="两个小题"><a href="#两个小题" class="headerlink" title="两个小题"></a>两个小题</h2><h3 id="第一题：518-零钱兑换-II"><a href="#第一题：518-零钱兑换-II" class="headerlink" title="第一题：518. 零钱兑换 II"></a>第一题：<a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a></h3><p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数</p><blockquote><p>实例：</p><p>输入：amount = 5, coins = [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p></blockquote><h3 id="第二题：377-组合总和-Ⅳ"><a href="#第二题：377-组合总和-Ⅳ" class="headerlink" title="第二题：377. 组合总和 Ⅳ"></a>第二题：<a href="https://leetcode-cn.com/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h3><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><blockquote><p>实例：</p><p>输入：nums = [1,2,3], target = 4<br>输出：7<br>解释：<br>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>请注意，顺序不同的序列被视作不同的组合</p></blockquote><h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><pre><code class="java">class Solution &#123;    public int change(int amount, int[] coins) &#123;        int[] dp=new int[amount+1];        dp[0]=1;        for(int i=0;i&lt;coins.length;i++)&#123;//遍历物品            for(int j=coins[i];j&lt;=amount;j++)&#123;//遍历背包                dp[j]+=dp[j-coins[i]];            &#125;        &#125;        return dp[amount];    &#125;&#125;</code></pre><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><pre><code class="java">class Solution &#123;    public int combinationSum4(int[] nums, int target) &#123;        int[] dp=new int[target+1];        dp[0]=1;        for(int i=0;i&lt;=target;i++)&#123;//遍历背包            for(int j=0;j&lt;nums.length;j++)&#123;//遍历物品                if(i-nums[j]&gt;=0)&#123;                    dp[i]+=dp[i-nums[j]];                &#125;            &#125;        &#125;        return dp[target];    &#125;&#125;</code></pre><h2 id="分析与小结"><a href="#分析与小结" class="headerlink" title="分析与小结"></a>分析与小结</h2><p>这个完全背包，这里有两种类型：组合和排列。</p><p>从代码可以看出来：组合问题for循环是先遍历物品，再遍历背包，而排列问题for循环先遍历背包，再遍历物品。</p><p>全是套路呀！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初识完全背包&quot;&gt;&lt;a href=&quot;#初识完全背包&quot; class=&quot;headerlink&quot; title=&quot;初识完全背包&quot;&gt;&lt;/a&gt;初识完全背包&lt;/h2&gt;&lt;p&gt;​        完全背包是背包问题的变形之一，老实说01背包我也才半知半解，今天看题解也还是雾中看花。完全</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="刷题心得" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 day-2</title>
    <link href="http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0day%202/"/>
    <id>http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0day%202/</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2021-09-24T10:25:23.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>好久没写博客了，虽然我的博客没人看，但是我觉得写博客是为了将自己的知识水平提高。写博客还可以让以后回顾知识变得更简单。之前一直没写主要是没啥兴趣，刷题在刚开始简直折磨，不夸张的说开始每一道题都是看答案的，有的看了答案也没弄懂，简直不知所云。对Java的集合类和数据结构也不是很熟悉，很多常用的方法函数不知道。经过20天左右的时间，我基本对刷题有一点的感觉了，开始越刷越快了。这个时候我想要慢下来，慢慢把刷的题总结一下。这就是再次写博客的理由。</p><h2 id="题目概述及解法"><a href="#题目概述及解法" class="headerlink" title="题目概述及解法"></a>题目概述及解法</h2><p>今天刷的还是回溯算法系列，这一题是：LeetCode第131题—<strong>分割回文串</strong></p><p>题目的意思是：<em>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</em></p><p><em>回文串 是正着读和反着读都一样的字符串。</em></p><p>示例 1：</p><p>输入：s = “aab”<br>输出：[[“a”,”a”,”b”],[“aa”,”b”]]<br>示例 2：</p><p>输入：s = “a”<br>输出：[[“a”]]</p><p>提示：</p><p>1 &lt;= s.length &lt;= 16<br>s 仅由小写英文字母组成</p><h3 id="解法代码："><a href="#解法代码：" class="headerlink" title="解法代码："></a>解法代码：</h3><pre><code class="java">class Solution &#123;    List&lt;List&lt;String&gt;&gt; res= new ArrayList&lt;&gt;();//存放正确结果的集合    Deque&lt;String&gt; path=new LinkedList&lt;&gt;();//存放单个正确结果(这里选择双端队列，若选择list删除时会出现错误)    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;        backtracking(s,0);        return res;    &#125;    public void backtracking(String s,int index)&#123;//回溯函数(也是递归函数)        //确定回溯的终止条件(本题是： 当截取字符串的位置到达字符串最后一位就说明此次获取完成)        if(index&gt;=s.length())&#123;            res.add(new ArrayList&lt;&gt;(path));            return;        &#125;        //for循环是解空间树的横向遍历，而回溯函数是解空间树的纵向遍历        for(int i=index;i&lt;s.length();i++)&#123;            //先判断是否是回文串，是就截取放入path中，不是就跳过这次循环            if(isHuiWen(s,index,i))&#123;                String str=s.substring(index,i+1);                path.addLast(str);            &#125;else&#123;                continue;            &#125;            backtracking(s,i+1);//回溯函数(i+1是为了不再重复的截取)            path.removeLast();//回溯 撤销之前处理节点的过程        &#125;            &#125;    //下面这个函数是判断是否是回文串    public boolean isHuiWen(String s,int index,int end)&#123;        for(int i=index,j=end;i&lt;j;i++,j--)&#123;            if(s.charAt(i)!=s.charAt(j))                return false;        &#125;        return true;    &#125;&#125;</code></pre><p>解法我在代码上做了详细的注释说明，主要就是截取字符串和数据结构Deque的选择。</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>虽然每天写的题不只一题，但是要是全部都记录下来，有点费时间，还是每天找一个喜欢的记录，这样也挺好的。</p><p>​                                                      <em><strong>加油</strong></em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;好久没写博客了，虽然我的博客没人看，但是我觉得写博客是为了将自己的知识水平提高。写博客还可以让以后回顾知识变得更简单。之前一</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="刷题心得" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>刷题日记 day-3</title>
    <link href="http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0day%203/"/>
    <id>http://example.com/2021/09/24/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0day%203/</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2021-09-24T08:29:05.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>LeetCode第46题：<em>全排列</em></p><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><p>示例 1：</p><p>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<br>示例 2：</p><p>输入：nums = [0,1]<br>输出：[[0,1],[1,0]]<br>示例 3：</p><p>输入：nums = [1]<br>输出：[[1]]</p><p>提示：</p><p>1 &lt;= nums.length &lt;= 6<br>-10 &lt;= nums[i] &lt;= 10<br>nums 中的所有整数 互不相同</p><h2 id="解决代码"><a href="#解决代码" class="headerlink" title="解决代码"></a>解决代码</h2><pre><code class="java">class Solution &#123;    List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();//存放正确结果的集合    List&lt;Integer&gt; path=new ArrayList&lt;&gt;();//存放单个正确的结果    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;        boolean[] used=new boolean[nums.length];//需要一个数组来判断集合的元素是否重复使用        backtracking(nums,used);        return res;    &#125;    //子集问题和排列问题最大的不同，就是函数参数不再需要index，而是换成了boolean数组    public void backtracking(int[] nums,boolean[] used)&#123;        //当path存放的元素到了全排列的数组的大小就可以停止，并传入res中        if(path.size()==nums.length)&#123;            res.add(new ArrayList&lt;&gt;(path));            return;        &#125;        for(int i=0;i&lt;nums.length;i++)&#123;            //used数组就是记录path里面哪些元素已经被使用了，一个排列里元素只能使用一次            if(used[i]==true)                continue;            used[i]=true;            path.add(nums[i]);            backtracking(nums,used);            path.remove(path.size()-1);            used[i]=false;        &#125;    &#125;&#125;</code></pre><h2 id="分析小结"><a href="#分析小结" class="headerlink" title="分析小结"></a>分析小结</h2><p>这个题目是回溯算法的另一个擅长的拿手好戏，全排列和子集、组合问题的最大不同就是不需要传起始地址，因为每一层的元素可以重复使用，但是在一个分支里每个元素都只能用一次。下面是我画的一张解空间树的图，可以加深理解。</p><p><img src="https://pic.imgdb.cn/item/614d87952ab3f51d91e49384.png" class="lazyload" data-srcset="https://pic.imgdb.cn/item/614d87952ab3f51d91e49384.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>同时也想说，第一次使用画图工具，好难用，但是不用这个肯定画的又丑又难看懂。还是要继续努力，学习新知识！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目概述&quot;&gt;&lt;a href=&quot;#题目概述&quot; class=&quot;headerlink&quot; title=&quot;题目概述&quot;&gt;&lt;/a&gt;题目概述&lt;/h2&gt;&lt;p&gt;LeetCode第46题：&lt;em&gt;全排列&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;给定一个不含重复数字的数组 nums ，返回其 所有可能的</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    
    <category term="刷题心得" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>标签测试</title>
    <link href="http://example.com/2021/09/24/%E6%A0%87%E7%AD%BE%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2021/09/24/%E6%A0%87%E7%AD%BE%E6%B5%8B%E8%AF%95/</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2021-09-24T08:27:10.600Z</updated>
    
    <content type="html"><![CDATA[<h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p>带 <u>下划线</u> 的文本；带 <emp>着重号</emp> 的文本；带 <wavy>波浪线</wavy> 的文本；带 <del>删除线</del> 的文本</p><p>键盘样式的文本：<kbd>⌘</kbd> + <kbd>D</kbd></p><p>密码样式的文本：<psw>这里没有验证码</psw></p><h3 id="note"><a href="#note" class="headerlink" title="note"></a>note</h3><div class="note"><p>这里可以是一段有用的希望能引人注意的信息</p></div><h3 id="checkbox"><a href="#checkbox" class="headerlink" title="checkbox"></a>checkbox</h3><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><h3 id="radio"><a href="#radio" class="headerlink" title="radio"></a>radio</h3><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><h3 id="timeline"><a href="#timeline" class="headerlink" title="timeline"></a>timeline</h3><div class="timeline"><div class="timenode"><div class="meta"><p><p>2021-09-23</p></p></div><div class="body"><p>timeline测试</p></div></div><div class="timenode"><div class="meta"><p><p>2021-09-22</p></p></div><div class="body"><p>1、</p></div></div><div class="timenode"><div class="meta"><p><p>2021-09-21</p></p></div><div class="body"><p>2、</p></div></div><div class="timenode"><div class="meta"><p><p>2021-09-23</p></p></div><div class="body"><p>3、</p></div></div></div><h3 id="folding"><a href="#folding" class="headerlink" title="folding"></a>folding</h3><details ><summary> 这是一个折叠框 </summary>              <div class='content'>              <p><img src="https://pic.imgdb.cn/item/614d54892ab3f51d919f6b04.jpg" class="lazyload" data-srcset="https://pic.imgdb.cn/item/614d54892ab3f51d919f6b04.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>              </div>            </details><h3 id="其他的还有好多元素实在太丰富了，我写个博客还用得着这么多？太看得起我了也hhh"><a href="#其他的还有好多元素实在太丰富了，我写个博客还用得着这么多？太看得起我了也hhh" class="headerlink" title="其他的还有好多元素实在太丰富了，我写个博客还用得着这么多？太看得起我了也hhh"></a>其他的还有好多元素实在太丰富了，我写个博客还用得着这么多？太看得起我了也hhh</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;text&quot;&gt;&lt;a href=&quot;#text&quot; class=&quot;headerlink&quot; title=&quot;text&quot;&gt;&lt;/a&gt;text&lt;/h3&gt;&lt;p&gt;带 &lt;u&gt;下划线&lt;/u&gt; 的文本；带 &lt;emp&gt;着重号&lt;/emp&gt; 的文本；带 &lt;wavy&gt;波浪线&lt;/wavy&gt; 的文本；带</summary>
      
    
    
    
    <category term="test" scheme="http://example.com/categories/test/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://example.com/2021/09/23/front-matter%E7%9A%84%E6%B5%8B%E8%AF%95/"/>
    <id>http://example.com/2021/09/23/front-matter%E7%9A%84%E6%B5%8B%E8%AF%95/</id>
    <published>2021-09-22T16:00:00.000Z</published>
    <updated>2021-09-23T05:41:26.588Z</updated>
    
    <content type="html"><![CDATA[<p>this is a test!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;this is a test!&lt;/p&gt;
</summary>
      
    
    
    
    <category term="test" scheme="http://example.com/categories/test/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="http://example.com/2021/09/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <id>http://example.com/2021/09/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</id>
    <published>2021-09-22T10:51:47.372Z</published>
    <updated>2021-09-22T10:53:03.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一个标题"><a href="#第一个标题" class="headerlink" title="第一个标题"></a>第一个标题</h2><h2 id="第二个标题"><a href="#第二个标题" class="headerlink" title="第二个标题"></a>第二个标题</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一个标题&quot;&gt;&lt;a href=&quot;#第一个标题&quot; class=&quot;headerlink&quot; title=&quot;第一个标题&quot;&gt;&lt;/a&gt;第一个标题&lt;/h2&gt;&lt;h2 id=&quot;第二个标题&quot;&gt;&lt;a href=&quot;#第二个标题&quot; class=&quot;headerlink&quot; title=&quot;第二个</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/09/22/hello-world/"/>
    <id>http://example.com/2021/09/22/hello-world/</id>
    <published>2021-09-22T10:34:25.959Z</published>
    <updated>2021-09-22T10:34:25.959Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
